.. _1.1.4_js:

1.1.4 7-Segment-Anzeige
=============================

Einführung
--------------

Lassen Sie uns versuchen, eine 7-Segment-Anzeige zu steuern, um eine Zahl von 0 bis 9 und
A bis F anzuzeigen.

Benötigte Komponenten
------------------------------

Für dieses Projekt benötigen wir die folgenden Komponenten.

.. image:: img/list_7_segment.png

Es ist definitiv praktisch, ein ganzes Set zu kaufen, hier ist der Link:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Name	
        - ARTIKEL IN DIESEM KIT
        - LINK
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

Sie können sie auch einzeln über die untenstehenden Links kaufen.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - KOMPONENTENBESCHREIBUNG
        - KAUF-LINK

    *   - :ref:`gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`breadboard`
        - |link_breadboard_buy|
    *   - :ref:`wires`
        - |link_wires_buy|
    *   - :ref:`resistor`
        - |link_resistor_buy|
    *   - :ref:`7_segment`
        - |link_7segment_buy|
    *   - :ref:`74hc595`
        - |link_74hc595_buy|

Schaltplan
---------------------

Verbinden Sie den ST_CP-Pin des 74HC595 mit dem Raspberry Pi GPIO18, SH_CP mit GPIO27, DS
mit GPIO17 und die parallelen Ausgangsports mit den 8 Segmenten der LED-Segmentanzeige. Geben Sie Daten im DS-Pin in das Schieberegister ein, wenn SH_CP (der Takteingang des Schieberegisters) an der steigenden Flanke ist, und in das Speicherregister, wenn ST_CP (der Takteingang des Speichers) an der steigenden Flanke ist. Dann können Sie die Zustände von SH_CP und ST_CP über die Raspberry Pi GPIOs steuern, um die serielle Dateneingabe in parallele Datenausgabe zu transformieren, um so Raspberry Pi GPIOs zu sparen und die Anzeige zu steuern.

.. image:: img/schematic_7_segment.png

Experimentelle Verfahren
--------------------------

**Schritt 1:** Bauen Sie den Schaltkreis.

.. image:: img/image73.png

**Schritt 2:** Navigieren Sie zum Ordner mit dem Code.

.. raw:: html

    <run></run>

.. code-block::

    cd ~/raphael-kit/nodejs/

**Schritt 3:** Führen Sie den Code aus.

.. raw:: html

    <run></run>

.. code-block::

    sudo node 7-segment_display.js

Nachdem der Code ausgeführt wurde, zeigt die 7-Segment-Anzeige 0-9, A-F an.

**Code**

.. code-block:: js

    const Gpio = require('pigpio').Gpio;

    const segCode = [0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e, 0x79, 0x71];

    const SDI = new Gpio(17, { mode: Gpio.OUTPUT });
    const RCLK = new Gpio(18, { mode: Gpio.OUTPUT });
    const SRCLK = new Gpio(27, { mode: Gpio.OUTPUT });

    function hc595_shift(dat) {
        for (let j = 0; j < 8; j++) {
            let code = 0x80 & (dat << j);
            if (code != 0) {
                code = 1;
            }
            SDI.digitalWrite(code);
            SRCLK.trigger(1,1);
        }
        RCLK.trigger(1,1);
    }

    let index = -1;
    setInterval(() => {
        index = (index+1)%16;
        hc595_shift(segCode[index]);
    }, 1000);


**Code-Erklärung**

.. code-block:: js

    const segCode = [0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71];

Definieren Sie ein Hexadezimal-Segment-Code-Array (gemeinsame Kathode) von 0 bis F.

.. code-block:: js

    const SDI = new Gpio(17, { mode: Gpio.OUTPUT });
    const RCLK = new Gpio(18, { mode: Gpio.OUTPUT });
    const SRCLK = new Gpio(27, { mode: Gpio.OUTPUT });

Initialisieren Sie die Pins 17, 18 und 27 im Ausgabemodus und kopieren Sie sie jeweils nach ``SDI``, ``RCLK`` und ``SRCLK``.

.. code-block:: js

    function hc595_shift(dat) {
        for (let j = 0; j < 8; j++) {
            let code = 0x80 & (dat << j);
            if (code != 0) {
                code = 1;
            }
            SDI.digitalWrite(code);
            SRCLK.trigger(1,1);
        }
        RCLK.trigger(1,1);
    }

Implementieren Sie eine ``hc595_shift``-Funktion, um die Felder im Array ``segCode`` in Zahlen umzuwandeln 
und sie auf der Digitalröhre anzuzeigen.

.. code-block:: js

    let code = 0x80 & (dat << j);
    if (code != 0) {
        code = 1;
    }
    SDI.digitalWrite(code); 

Weisen Sie die Daten von dat bitweise SDI(DS) zu. 
Hier nehmen wir an, dat=0x3f(0011 1111). Wenn j=2 ist, wird 0x3f 2 Bits nach rechts verschoben (<<). 
1111 1100 (0x3f << 2) & 1000 0000 (0x80) = 1000 0000, ist wahr.
Zu diesem Zeitpunkt wird 1 auf SDI geschrieben.

.. code-block:: js

    SRCLK.trigger(1,1);

Erzeugen Sie einen ansteigenden Flankenimpuls und verschieben Sie die DS-Daten in das Schieberegister.

``trigger(pulseLen, level)``
    * pulseLen - Impulslänge in Mikrosekunden (1 - 100)
    * level - 0 oder 1

Sendet einen Triggerimpuls an das GPIO. 
Das GPIO wird für pulseLen Mikrosekunden auf das Level gesetzt und dann auf nicht-Level zurückgesetzt.

.. code-block:: js

    RCLK.trigger(1,1);

Erzeugen Sie einen ansteigenden Flankenimpuls und verschieben Sie die Daten vom Schieberegister in das Speicherregister.

.. code-block:: js

    let index = -1;
    setInterval(() => {
        index = (index+1)%16;
        hc595_shift(segCode[index]);
    }, 1000);

Verwenden Sie schließlich die Funktion ``hc595_shift()`` um die Felder in ``segCode`` umzuwandeln 
und sie durch die Digitalröhre anzuzeigen.

Phänomen-Bild
---------------------------

.. image:: img/image74.jpeg





