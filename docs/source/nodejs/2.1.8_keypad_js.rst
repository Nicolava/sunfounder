.. note::

    Ciao, benvenuto nella Community di appassionati di Raspberry Pi, Arduino e ESP32 di SunFounder su Facebook! Approfondisci le tue conoscenze su Raspberry Pi, Arduino ed ESP32 insieme ad altri appassionati.

    **PerchÃ© unirti a noi?**

    - **Supporto esperto**: Risolvi i problemi post-vendita e le sfide tecniche con l'aiuto della nostra community e del nostro team.
    - **Impara e condividi**: Scambia consigli e tutorial per migliorare le tue competenze.
    - **Anteprime esclusive**: Ottieni accesso anticipato ai nuovi annunci di prodotti e alle anteprime.
    - **Sconti speciali**: Godi di sconti esclusivi sui nostri prodotti piÃ¹ recenti.
    - **Promozioni festive e giveaway**: Partecipa a concorsi e promozioni durante le festivitÃ .

    ðŸ‘‰ Pronto a esplorare e creare con noi? Clicca su [|link_sf_facebook|] e unisciti oggi stesso!

.. _2.1.8_js:

2.1.8 Tastiera
=================

Introduzione
---------------

Una tastiera Ã¨ una matrice rettangolare di pulsanti. In questo progetto, 
utilizzeremo la tastiera per inserire caratteri.

Componenti necessari
-------------------------

In questo progetto, abbiamo bisogno dei seguenti componenti.

.. image:: ../img/list_2.1.5_keypad.png

Ãˆ sicuramente conveniente acquistare un kit completo, ecco il link:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nome
        - OGGETTI IN QUESTO KIT
        - LINK
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

Puoi anche acquistarli separatamente dai link sottostanti.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUZIONE AI COMPONENTI
        - LINK PER L'ACQUISTO

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_keypad`
        - \-

Schema elettrico
----------------------

.. image:: ../img/image315.png


.. image:: ../img/image316.png


Procedure sperimentali
---------------------------

**Passo 1:** Costruisci il circuito.

.. image:: ../img/image186.png

**Passo 2:** Apri il file del codice.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/nodejs/

**Passo 3:** Esegui il codice.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo node keypad.js

Dopo l'esecuzione del codice, i valori dei pulsanti premuti sulla 
tastiera (valore pulsante) verranno stampati sullo schermo.

**Codice**

.. code-block:: js

    const Gpio = require('pigpio').Gpio; 

    var rowsPins = [18,23,24,25];
    var colsPins = [10,6,27,17];
    var keys = ["1","2","3","A",
            "4","5","6","B",
            "7","8","9","C",
            "*","0","#","D"];      

    for(let i=0;i<rowsPins.length;i++){
        rowsPins[i] = new Gpio(rowsPins[i],{mode: Gpio.OUTPUT})
    }
    for(let i=0;i<colsPins.length;i++){
        colsPins[i] = new Gpio(colsPins[i],{
            mode: Gpio.INPUT,
            pullUpDown: Gpio.PUD_DOWN,
            edge: Gpio.RISING_EDGE
        })
    }

    var last_key_pressed = 0;

    var col=-1;
    for(let i=0;i<colsPins.length;i++){
        colsPins[i].on('interrupt',()=>{
            col=i;
            pressed_keys=keys[row*colsPins.length+col];
            if(last_key_pressed!=pressed_keys){
                console.log(`${pressed_keys}`);
            }
            last_key_pressed = pressed_keys;
        });
    }

    var row=-1;
    setInterval(() => {
        row=(row+1)%rowsPins.length;
        for(let i=0;i<rowsPins.length;i++){
            rowsPins[i].digitalWrite(0);
        }
        rowsPins[row].digitalWrite(1);
    }, 10);



**Spiegazione del Codice**

.. code-block:: js

    const Gpio = require('pigpio').Gpio; 

    var rowsPins = [18,23,24,25];
    var colsPins = [10,6,27,17];
    var keys = ["1","2","3","A",
            "4","5","6","B",
            "7","8","9","C",
            "*","0","#","D"];      

    for(let i=0;i<rowsPins.length;i++){
        rowsPins[i] = new Gpio(rowsPins[i],{mode: Gpio.OUTPUT})
    }
    for(let i=0;i<colsPins.length;i++){
        colsPins[i] = new Gpio(colsPins[i],{
            mode: Gpio.INPUT,
            pullUpDown: Gpio.PUD_DOWN,
            edge: Gpio.RISING_EDGE
        })
    }

Nello stile della tastiera, dichiara due set di pin e una matrice.

Quattro dei pin rappresentano le righe della tastiera, impostali in 
modalitÃ  OUTPUT; gli altri quattro pin rappresentano le colonne della tastiera, 
impostali in modalitÃ  INPUT e configura l'interrupt sul fronte di salita.

Il principio per cui il controllore principale puÃ² ottenere il valore del tasto Ã¨ 
il seguente: 
I quattro pin delle righe forniscono livelli alti a turno, e se un pulsante viene premuto,
il pin della colonna corrispondente riceverÃ  il livello alto rilasciato dal pin della riga, 
il che innescherÃ  l'interrupt sul fronte di salita.

Ad esempio, se premo il pulsante **3**, quando i pin delle righe 2, 3 e 4 rilasciano il 
livello alto, non ci saranno effetti;
Quando il pin della prima riga rilascia il livello alto, il terzo pin della colonna sarÃ  
in grado di ottenere il livello alto e innescare l'interrupt sul fronte di salita. A questo 
punto, i pin delle colonne 1, 2 e 4 non innescheranno alcun evento.

Poi, secondo il pin della prima riga che rilascia il livello alto e il terzo pin della 
colonna che riceve il livello alto, il controllore principale sarÃ  in grado di sapere 
che la posizione del pulsante premuto Ã¨ (1,3), ovvero il pulsante **3**.

.. image:: ../img/image187.png

.. code-block:: js

    var row=-1;
    setInterval(() => {
        row=(row+1)%rowsPins.length;
        for(let i=0;i<rowsPins.length;i++){
            rowsPins[i].digitalWrite(0);
        }
        rowsPins[row].digitalWrite(1);
    }, 10);

I quattro pin delle righe vengono forniti periodicamente con il livello alto, e la variabile ``row`` viene utilizzata per localizzare il pin della riga attualmente in funzione.

.. code-block:: js

    var col=-1;
    for(let i=0;i<colsPins.length;i++){
        colsPins[i].on('interrupt',()=>{
            col=i;
            // pressed_keys=keys[row*colsPins.length+col];
            // if(last_key_pressed!=pressed_keys){
            //     console.log(`${pressed_keys}`);
            // }
            // last_key_pressed = pressed_keys;
        });
    }

Imposta funzioni di interrupt per i quattro pin delle colonne,
e la variabile ``col`` viene utilizzata per localizzare i pin delle colonne che innescano l'evento di interrupt sul fronte di salita.

.. code-block:: js

    pressed_keys=keys[row*colsPins.length+col];
    if(last_key_pressed!=pressed_keys){
        console.log(`${pressed_keys}`);
    }
    last_key_pressed = pressed_keys;

C'Ã¨ anche un pezzo di codice nella funzione di interruzione che ottiene il valore specifico del tasto dalla matrice ``keys`` in base a ``row`` e ``col``.
E ogni volta che si ottiene un nuovo valore, il valore viene stampato.

Immagine del fenomeno
--------------------------

.. image:: ../img/image188.jpeg

