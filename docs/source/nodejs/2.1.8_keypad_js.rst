.. note::

    ¡Hola! Bienvenidos a la comunidad de entusiastas de SunFounder Raspberry Pi, Arduino y ESP32 en Facebook. Sumérgete más en Raspberry Pi, Arduino y ESP32 con otros entusiastas.

    **¿Por qué unirte?**

    - **Soporte experto**: Resuelve problemas postventa y desafíos técnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprende y comparte**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Previews exclusivos**: Obtén acceso anticipado a nuevos anuncios de productos y avances.
    - **Descuentos especiales**: Disfruta de descuentos exclusivos en nuestros productos más nuevos.
    - **Promociones festivas y sorteos**: Participa en sorteos y promociones navideñas.

    👉 ¿Listo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y únete hoy mismo.

.. _2.1.8_js:

2.1.8 Teclado Matricial
=============================

Introducción
------------------

Un teclado matricial es una matriz rectangular de botones. En este proyecto, lo utilizaremos para ingresar caracteres.

Componentes Necesarios
----------------------------

En este proyecto, necesitamos los siguientes componentes.

.. image:: ../img/list_2.1.5_keypad.png

Es definitivamente conveniente comprar un kit completo, aquí tienes el enlace:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nombre
        - ARTÍCULOS EN ESTE KIT
        - ENLACE
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

También puedes comprarlos por separado en los enlaces a continuación.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCCIÓN DE COMPONENTES
        - ENLACE DE COMPRA

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_keypad`
        - \-

Diagrama Esquemático
-------------------------

.. image:: ../img/image315.png

.. image:: ../img/image316.png


Procedimientos Experimentales
----------------------------------

**Paso 1:** Construye el circuito.

.. image:: ../img/image186.png

**Paso 2:** Abre el archivo de código.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/nodejs/

**Paso 3:** Ejecuta el código.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo node keypad.js

Después de ejecutar el código, los valores de los botones presionados en el teclado
 (valor del botón) se imprimirán en la pantalla.

**Código**

.. code-block:: js

    const Gpio = require('pigpio').Gpio; 

    var rowsPins = [18,23,24,25];
    var colsPins = [10,6,27,17];
    var keys = ["1","2","3","A",
            "4","5","6","B",
            "7","8","9","C",
            "*","0","#","D"];      

    for(let i=0;i<rowsPins.length;i++){
        rowsPins[i] = new Gpio(rowsPins[i],{mode: Gpio.OUTPUT})
    }
    for(let i=0;i<colsPins.length;i++){
        colsPins[i] = new Gpio(colsPins[i],{
            mode: Gpio.INPUT,
            pullUpDown: Gpio.PUD_DOWN,
            edge: Gpio.RISING_EDGE
        })
    }

    var last_key_pressed = 0;

    var col=-1;
    for(let i=0;i<colsPins.length;i++){
        colsPins[i].on('interrupt',()=>{
            col=i;
            pressed_keys=keys[row*colsPins.length+col];
            if(last_key_pressed!=pressed_keys){
                console.log(`${pressed_keys}`);
            }
            last_key_pressed = pressed_keys;
        });
    }

    var row=-1;
    setInterval(() => {
        row=(row+1)%rowsPins.length;
        for(let i=0;i<rowsPins.length;i++){
            rowsPins[i].digitalWrite(0);
        }
        rowsPins[row].digitalWrite(1);
    }, 10);

**Explicación del Código**

.. code-block:: js

    const Gpio = require('pigpio').Gpio; 

    var rowsPins = [18,23,24,25];
    var colsPins = [10,6,27,17];
    var keys = ["1","2","3","A",
            "4","5","6","B",
            "7","8","9","C",
            "*","0","#","D"];      

    for(let i=0;i<rowsPins.length;i++){
        rowsPins[i] = new Gpio(rowsPins[i],{mode: Gpio.OUTPUT})
    }
    for(let i=0;i<colsPins.length;i++){
        colsPins[i] = new Gpio(colsPins[i],{
            mode: Gpio.INPUT,
            pullUpDown: Gpio.PUD_DOWN,
            edge: Gpio.RISING_EDGE
        })
    }

En el estilo del teclado, declaramos dos conjuntos de pines y una matriz.

Cuatro de los pines son las filas del teclado, se configuran en modo OUTPUT;
Los otros cuatro pines son las columnas del teclado, se configuran en modo INPUT, y se configura la interrupción de borde ascendente para ellos.

El principio por el cual el controlador principal puede obtener el valor de la tecla es el siguiente:
Los cuatro pines de fila proporcionan un nivel alto por turno, si se presiona un botón,
El pin de la columna correspondiente obtendrá el nivel alto liberado por el pin de fila, lo que desencadenará la interrupción de borde ascendente.

Por ejemplo, si presiono el botón **3**, cuando los pines de fila 2, 3 y 4 liberan el nivel alto, no hay efecto;
Cuando el pin de fila en la primera posición libera el nivel alto, el tercer pin de la columna podrá obtener el nivel alto y desencadenar la interrupción de borde ascendente. En ese momento, los pines de columna 1, 2 y 4 no desencadenan ningún evento.

Luego, de acuerdo con el pin de fila 1 que libera el nivel alto y el pin de columna 3 que obtiene el nivel alto, el controlador principal podrá saber que la posición del botón presionado es (1,3), que es el botón **3**.

.. image:: ../img/image187.png

.. code-block:: js

    var row=-1;
    setInterval(() => {
        row=(row+1)%rowsPins.length;
        for(let i=0;i<rowsPins.length;i++){
            rowsPins[i].digitalWrite(0);
        }
        rowsPins[row].digitalWrite(1);
    }, 10);

Los cuatro pines de fila se suministran periódicamente con un nivel alto, y la variable ``row`` se utiliza para localizar el pin de fila que está funcionando actualmente.

.. code-block:: js

    var col=-1;
    for(let i=0;i<colsPins.length;i++){
        colsPins[i].on('interrupt',()=>{
            col=i;
            // pressed_keys=keys[row*colsPins.length+col];
            // if(last_key_pressed!=pressed_keys){
            //     console.log(`${pressed_keys}`);
            // }
            // last_key_pressed = pressed_keys;
        });
    }

Configura funciones de interrupción para los cuatro pines de columna,
y la variable ``col`` se utiliza para localizar los pines de columna que desencadenan el evento de interrupción de borde ascendente.

.. code-block:: js

    pressed_keys=keys[row*colsPins.length+col];
    if(last_key_pressed!=pressed_keys){
        console.log(`${pressed_keys}`);
    }
    last_key_pressed = pressed_keys;

También hay un fragmento de código en la función de interrupción para obtener el valor específico de la tecla desde la matriz ``keys`` de acuerdo con ``row`` y ``col``.
Y cada vez que se obtiene un nuevo valor de tecla, se imprime el valor.

Imagen del Fenómeno
-----------------------

.. image:: ../img/image188.jpeg


