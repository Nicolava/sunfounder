.. note::

    Ciao, benvenuto nella community di appassionati di SunFounder Raspberry Pi, Arduino & ESP32 su Facebook! Approfondisci l'utilizzo di Raspberry Pi, Arduino e ESP32 insieme ad altri appassionati.

    **PerchÃ© Unirsi?**

    - **Supporto Esperto**: Risolvi i problemi post-vendita e le sfide tecniche con l'aiuto della nostra community e del nostro team.
    - **Impara & Condividi**: Scambia suggerimenti e tutorial per migliorare le tue competenze.
    - **Anteprime Esclusive**: Ottieni accesso anticipato agli annunci dei nuovi prodotti e anteprime esclusive.
    - **Sconti Speciali**: Goditi sconti esclusivi sui nostri prodotti piÃ¹ recenti.
    - **Promozioni Festive e Giveaway**: Partecipa a promozioni e giveaway durante le festivitÃ .

    ðŸ‘‰ Pronto a esplorare e creare con noi? Clicca [|link_sf_facebook|] e unisciti oggi stesso!

.. _4.1.15_py:

4.1.15 Campanello d'Allarme
================================

Introduzione
-----------------

In questo progetto, realizzeremo un dispositivo di allarme manuale. Puoi sostituire 
l'interruttore a levetta con un termistore o un sensore fotosensibile per creare un 
allarme temperatura o un allarme luminoso.

Componenti Necessari
------------------------------

Per questo progetto, avremo bisogno dei seguenti componenti.

.. image:: ../img/list_Alarm_Bell.png
    :align: center

Ãˆ sicuramente conveniente acquistare un intero kit, ecco il link:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nome
        - ELEMENTI IN QUESTO KIT
        - LINK
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

Puoi anche acquistarli separatamente dai link seguenti.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUZIONE COMPONENTE
        - LINK PER L'ACQUISTO

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|
    *   - :ref:`cpn_buzzer`
        - |link_passive_buzzer_buy|
    *   - :ref:`cpn_slide_switch`
        - |link_slide_switch_buy|
    *   - :ref:`cpn_transistor`
        - |link_transistor_buy|
    *   - :ref:`cpn_capacitor`
        - |link_capacitor_buy|

Schema del Circuito
-------------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO22       Pin 15   3        22
============ ======== ======== ===

.. image:: ../img/Schematic_three_one10.png
   :align: center

Procedure Sperimentali
-----------------------------

**Passo 1**: Costruisci il circuito.

.. image:: ../img/image266.png

**Passo 2:** Cambia la directory.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python/

**Passo 3:** Esegui.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 4.1.15_AlarmBell.py

Dopo l'avvio del programma, l'interruttore a levetta verrÃ  spostato verso destra, 
e il cicalino emetterÃ  suoni di allarme. Allo stesso tempo, i LED rosso e verde 
lampeggeranno a una certa frequenza.

**Codice**

.. note::
    Puoi **Modificare/Resettare/Copiare/Eseguire/Fermare** il codice qui sotto. Ma prima devi accedere al percorso del codice sorgente come ``raphael-kit/python``.

.. raw:: html

    <run></run>

.. code-block:: python

    #!/usr/bin/env python3

    import RPi.GPIO as GPIO
    import time
    import threading

    BeepPin=22
    ALedPin=17
    BLedPin=27
    switchPin=18

    Buzz=0
    flag =0
    note=150
    pitch=20

    def setup():
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(BeepPin, GPIO.OUT)
        GPIO.setup(ALedPin,GPIO.OUT,initial=GPIO.LOW)
        GPIO.setup(BLedPin,GPIO.OUT,initial=GPIO.LOW)
        GPIO.setup(switchPin,GPIO.IN)
        global Buzz
        Buzz=GPIO.PWM(BeepPin,note)

    def ledWork():
        while flag:
            GPIO.output(ALedPin,GPIO.HIGH)
            time.sleep(0.5)
            GPIO.output(ALedPin,GPIO.LOW)
            GPIO.output(BLedPin,GPIO.HIGH)
            time.sleep(0.5)
            GPIO.output(BLedPin,GPIO.LOW)

    def buzzerWork():
        global pitch
        global note
        while flag:
            if note >= 800 or note <=130:
                pitch = -pitch
            note = note + pitch 
            Buzz.ChangeFrequency(note)
            time.sleep(0.01)

    def on():
        global flag
        flag = 1
        Buzz.start(50)
        tBuzz = threading.Thread(target=buzzerWork) 
        tBuzz.start()
        tLed = threading.Thread(target=ledWork) 
        tLed.start()    

    def off():
        global flag
        flag = 0
        Buzz.stop()
        GPIO.output(ALedPin,GPIO.LOW)
        GPIO.output(BLedPin,GPIO.LOW)      

    def main():
        lastState=0
        while True:
            currentState =GPIO.input(switchPin)
            if currentState == 1 and lastState == 0:
                on()
            elif currentState == 0 and lastState == 1:
                off()
            lastState=currentState

    def destroy():
        off()
        GPIO.cleanup()

    if __name__ == '__main__':
        setup()
        try:
            main()
        except KeyboardInterrupt:
            destroy()

**Spiegazione del Codice**

.. code-block:: python

    importÂ threading

Qui, importiamo il modulo ``Threading`` che ti permette di eseguire piÃ¹ 
operazioni contemporaneamente, mentre i programmi normali possono eseguire 
il codice solo dall'alto verso il basso. Con il modulo ``Threading``, il 
LED e il cicalino possono funzionare separatamente.

.. code-block:: python

    defÂ ledWork():
    Â Â Â Â whileÂ flag:
    Â Â Â Â Â Â Â Â GPIO.output(ALedPin,GPIO.HIGH)
    Â Â Â Â Â Â Â Â time.sleep(0.5)
    Â Â Â Â Â Â Â Â GPIO.output(ALedPin,GPIO.LOW)
    Â Â Â Â Â Â Â Â GPIO.output(BLedPin,GPIO.HIGH)
    Â Â Â Â Â Â Â Â time.sleep(0.5)
    Â Â Â Â Â Â Â Â GPIO.output(BLedPin,GPIO.LOW)

La funzione ``ledWork()`` imposta lo stato operativo dei 2 LED:
mantiene acceso il LED verde per 0,5s e poi lo spegne;
allo stesso modo, mantiene acceso il LED rosso per 0,5s e poi lo spegne.

.. code-block:: python

    defÂ buzzerWork():
    Â Â Â Â globalÂ pitch
    Â Â Â Â globalÂ note
    Â Â Â Â whileÂ flag:
    Â Â Â Â Â Â Â Â ifÂ noteÂ >=Â 800Â orÂ noteÂ <=130:
    Â Â Â Â Â Â Â Â Â Â Â Â pitchÂ =Â -pitch
    Â Â Â Â Â Â Â Â noteÂ =Â noteÂ +Â pitchÂ 
    Â Â Â Â Â Â Â Â Buzz.ChangeFrequency(note)
    Â Â Â Â Â Â Â Â time.sleep(0.01)

La funzione ``buzzerWork()`` Ã¨ utilizzata per impostare lo stato operativo del cicalino.
Qui impostiamo la frequenza tra 130 e 800, per accumulare o decrescere
a intervalli di 20.

.. code-block:: python

    defÂ on():
    Â Â Â Â globalÂ flag
    Â Â Â Â flagÂ =Â 1
    Â Â Â Â Buzz.start(50)
    Â Â Â Â tBuzzÂ =Â threading.Thread(target=buzzerWork)Â 
    Â Â Â Â tBuzz.start()
    Â Â Â Â tLedÂ =Â threading.Thread(target=ledWork)Â 
    Â Â Â Â tLed.start()Â Â 

Nella funzione ``on()`` :

1) Definiamo la variabile ``flag=1``, che indica l'inizio del controllo
   del thread.

2) Avviamo il cicalino, impostando il ciclo di lavoro al 50%.

3) Creiamo **2** thread separati affinchÃ© i LED e il cicalino possano funzionare 
   contemporaneamente.

La funzione ``threading.Thread()`` viene utilizzata per creare il thread e il suo prototipo Ã¨ il seguente:

   ``classÂ threading.Thread(group=None,Â target=None,Â name=None,Â args=(),Â kwargs={},Â *,Â daemon=None)``

Tra i metodi di costruzione, il parametro principale Ã¨ ``target``,
dobbiamo assegnare un oggetto callable (in questo caso le funzioni ``ledWork``
e ``buzzerWork``) al parametro ``target``.

Successivamente, ``start()`` viene chiamato per avviare l'oggetto thread, ad esempio, ``tBuzz.start()`` avvia il nuovo thread ``tBuzz``.

.. code-block:: python

    defÂ off():
    Â Â Â Â globalÂ flag
    Â Â Â Â flagÂ =Â 0
    Â Â Â Â Buzz.stop()
    Â Â Â Â GPIO.output(ALedPin,GPIO.LOW)
    Â Â Â Â GPIO.output(BLedPin,GPIO.LOW)

La funzione ``off()`` definisce ``flag=0`` per uscire dai thread
**ledWork** e **buzzerWork** e quindi spegnere il cicalino e i LED.

.. code-block:: python

    defÂ main():
    Â Â Â Â lastState=0
    Â Â Â Â whileÂ True:
    Â Â Â Â Â Â Â Â currentStateÂ =GPIO.input(switchPin)
    Â Â Â Â Â Â Â Â ifÂ currentStateÂ ==Â 1Â andÂ lastStateÂ ==Â 0:
    Â Â Â Â Â Â Â Â Â Â Â Â on()
    Â Â Â Â Â Â Â Â elifÂ currentStateÂ ==Â 0Â andÂ lastStateÂ ==Â 1:
    Â Â Â Â Â Â Â Â Â Â Â Â off()
    Â Â Â Â Â Â Â Â lastState=currentState

``main()`` contiene l'intero processo del programma: innanzitutto legge il 
valore dell'interruttore a slitta; se l'interruttore Ã¨ spostato a destra 
(il valore di lettura Ã¨ 1), viene chiamata la funzione ``on()``, e il cicalino 
viene attivato per emettere suoni mentre i LED rosso e verde lampeggiano. 
Altrimenti, il cicalino e i LED non funzionano.

Immagine del fenomeno
------------------------

.. image:: ../img/image267.jpeg
   :align: center