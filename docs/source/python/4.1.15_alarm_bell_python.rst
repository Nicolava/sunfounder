.. note::

    Hallo und willkommen in der SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasten-Gemeinschaft auf Facebook! Tauchen Sie tiefer ein in die Welt von Raspberry Pi, Arduino und ESP32 mit anderen Enthusiasten.

    **Warum beitreten?**

    - **Expertenunterst√ºtzung**: L√∂sen Sie Nachverkaufsprobleme und technische Herausforderungen mit Hilfe unserer Gemeinschaft und unseres Teams.
    - **Lernen & Teilen**: Tauschen Sie Tipps und Anleitungen aus, um Ihre F√§higkeiten zu verbessern.
    - **Exklusive Vorschauen**: Erhalten Sie fr√ºhzeitigen Zugang zu neuen Produktank√ºndigungen und exklusiven Einblicken.
    - **Spezialrabatte**: Genie√üen Sie exklusive Rabatte auf unsere neuesten Produkte.
    - **Festliche Aktionen und Gewinnspiele**: Nehmen Sie an Gewinnspielen und Feiertagsaktionen teil.

    üëâ Sind Sie bereit, mit uns zu erkunden und zu erschaffen? Klicken Sie auf [|link_sf_facebook|] und treten Sie heute bei!

.. _4.1.15_py:

4.1.15 Alarmglocke
==========================

Einf√ºhrung
-----------------

In diesem Projekt werden wir ein manuelles Alarmsystem erstellen. Sie k√∂nnen den Kippschalter durch einen Thermistor oder einen lichtempfindlichen Sensor ersetzen, um einen Temperaturalarm oder einen Lichtalarm zu erstellen.

Erforderliche Komponenten
------------------------------

F√ºr dieses Projekt ben√∂tigen wir die folgenden Komponenten.

.. image:: ../img/list_Alarm_Bell.png
    :align: center

Es ist sicherlich praktisch, ein gesamtes Kit zu kaufen, hier ist der Link:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Name	
        - ARTIKEL IN DIESEM KIT
        - LINK
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

Sie k√∂nnen sie auch einzeln √ºber die untenstehenden Links kaufen.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - KOMPONENTENBESCHREIBUNG
        - KAUF-LINK

    *   - :ref:`cpn_gpio_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|
    *   - :ref:`cpn_Buzzer`
        - |link_passive_buzzer_buy|
    *   - :ref:`cpn_slide_switch`
        - |link_slide_switch_buy|
    *   - :ref:`cpn_transistor`
        - |link_transistor_buy|
    *   - :ref:`cpn_capacitor`
        - |link_capacitor_buy|

Schaltbild
-------------------------

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
GPIO22       Pin 15   3        22
============ ======== ======== ===

.. image:: ../img/Schematic_three_one10.png
   :align: center

Experimentelle Verfahren
-----------------------------

**Schritt 1**: Schalten Sie den Stromkreis.

.. image:: ../img/image266.png

**Schritt 2:** Verzeichnis wechseln.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python/

**Schritt 3:** Ausf√ºhren.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 4.1.15_AlarmBell.py

Nach dem Start des Programms wird der Kippschalter nach rechts geschaltet und der Summer gibt Alarmsignale aus. Gleichzeitig blinken die roten und gr√ºnen LEDs mit einer bestimmten Frequenz.

**Code**

.. note::
    Sie k√∂nnen den untenstehenden Code **Modifizieren/Zur√ºcksetzen/Kopieren/Ausf√ºhren/Stoppen**. Davor m√ºssen Sie jedoch zum Quellcode-Pfad, wie ``raphael-kit/python``, navigieren.

.. raw:: html

    <run></run>

.. code-block:: python

    #!/usr/bin/env python3

    import RPi.GPIO as GPIO
    import time
    import threading

    BeepPin=22
    ALedPin=17
    BLedPin=27
    switchPin=18

    Buzz=0
    flag =0
    note=150
    pitch=20

    def setup():
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(BeepPin, GPIO.OUT)
        GPIO.setup(ALedPin,GPIO.OUT,initial=GPIO.LOW)
        GPIO.setup(BLedPin,GPIO.OUT,initial=GPIO.LOW)
        GPIO.setup(switchPin,GPIO.IN)
        global Buzz
        Buzz=GPIO.PWM(BeepPin,note)

    def ledWork():
        while flag:
            GPIO.output(ALedPin,GPIO.HIGH)
            time.sleep(0.5)
            GPIO.output(ALedPin,GPIO.LOW)
            GPIO.output(BLedPin,GPIO.HIGH)
            time.sleep(0.5)
            GPIO.output(BLedPin,GPIO.LOW)

    def buzzerWork():
        global pitch
        global note
        while flag:
            if note >= 800 or note <=130:
                pitch = -pitch
            note = note + pitch 
            Buzz.ChangeFrequency(note)
            time.sleep(0.01)

    def on():
        global flag
        flag = 1
        Buzz.start(50)
        tBuzz = threading.Thread(target=buzzerWork) 
        tBuzz.start()
        tLed = threading.Thread(target=ledWork) 
        tLed.start()    

    def off():
        global flag
        flag = 0
        Buzz.stop()
        GPIO.output(ALedPin,GPIO.LOW)
        GPIO.output(BLedPin,GPIO.LOW)      

    def main():
        lastState=0
        while True:
            currentState =GPIO.input(switchPin)
            if currentState == 1 and lastState == 0:
                on()
            elif currentState == 0 and lastState == 1:
                off()
            lastState=currentState

    def destroy():
        off()
        GPIO.cleanup()

    if __name__ == '__main__':
        setup()
        try:
            main()
        except KeyboardInterrupt:
            destroy()

**Code-Erkl√§rung**

.. code-block:: python

    import¬†threading

Hier importieren wir das Modul ``Threading``, welches es erm√∂glicht,
mehrere Dinge gleichzeitig zu tun, w√§hrend normale Programme Code nur
von oben nach unten ausf√ºhren k√∂nnen. Mit den ``Threading``-Modulen k√∂nnen
die LED und der Summer getrennt voneinander arbeiten.

.. code-block:: python

    def¬†ledWork():
    ¬†¬†¬†¬†while¬†flag:
    ¬†¬†¬†¬†¬†¬†¬†¬†GPIO.output(ALedPin,GPIO.HIGH)
    ¬†¬†¬†¬†¬†¬†¬†¬†time.sleep(0.5)
    ¬†¬†¬†¬†¬†¬†¬†¬†GPIO.output(ALedPin,GPIO.LOW)
    ¬†¬†¬†¬†¬†¬†¬†¬†GPIO.output(BLedPin,GPIO.HIGH)
    ¬†¬†¬†¬†¬†¬†¬†¬†time.sleep(0.5)
    ¬†¬†¬†¬†¬†¬†¬†¬†GPIO.output(BLedPin,GPIO.LOW)

Die Funktion ``ledWork()`` hilft, den Arbeitszustand dieser 2 LEDs zu definieren:
Sie l√§sst die gr√ºne LED f√ºr 0,5s leuchten und schaltet sie dann aus;
ebenso l√§sst sie die rote LED f√ºr 0,5s leuchten und schaltet sie dann aus.

.. code-block:: python

    def¬†buzzerWork():
    ¬†¬†¬†¬†global¬†pitch
    ¬†¬†¬†¬†global¬†note
    ¬†¬†¬†¬†while¬†flag:
    ¬†¬†¬†¬†¬†¬†¬†¬†if¬†note¬†>=¬†800¬†or¬†note¬†<=130:
    ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†pitch¬†=¬†-pitch
    ¬†¬†¬†¬†¬†¬†¬†¬†note¬†=¬†note¬†+¬†pitch¬†
    ¬†¬†¬†¬†¬†¬†¬†¬†Buzz.ChangeFrequency(note)
    ¬†¬†¬†¬†¬†¬†¬†¬†time.sleep(0.01)

Die Funktion ``buzzWork()`` wird verwendet, um den Arbeitszustand des Summers zu definieren.
Hier setzen wir die Frequenz zwischen 130 und 800 und lassen sie in einem Intervall von 20 ansteigen oder abfallen.

.. code-block:: python

    def¬†on():
    ¬†¬†¬†¬†global¬†flag
    ¬†¬†¬†¬†flag¬†=¬†1
    ¬†¬†¬†¬†Buzz.start(50)
    ¬†¬†¬†¬†tBuzz¬†=¬†threading.Thread(target=buzzerWork)¬†
    ¬†¬†¬†¬†tBuzz.start()
    ¬†¬†¬†¬†tLed¬†=¬†threading.Thread(target=ledWork)¬†
    ¬†¬†¬†¬†tLed.start()¬†¬†

In der Funktion ``on()`` :

1) Definieren Sie die Marke ‚Äûflag=1‚Äú, die das Ende des Steuerthreads anzeigt.

2) Starten Sie den Summer und setzen Sie den Tastverh√§ltnis auf 50%.

3) Erstellen Sie **2** separate Threads, damit die LED und der Summer gleichzeitig arbeiten k√∂nnen.

Die Funktion ``threading.Thread()`` wird verwendet, um den Thread zu erstellen, und ihr Prototyp lautet:

   ``class¬†threading.Thread(group=None,¬†target=None,¬†name=None,¬†args=(),¬†kwargs={},¬†*,¬†daemon=None)``

Unter den Konstruktionsmethoden ist ``target`` der Hauptparameter,
wir m√ºssen ein aufrufbares Objekt (hier die Funktionen ``ledWork`` und ``BuzzWork``) zu ``target`` zuweisen.

Danach wird ``start()`` aufgerufen, um das Thread-Objekt zu starten, z.B. wird ``tBuzz.start()`` verwendet, um den neu installierten Thread ``tBuzz`` zu starten.

.. code-block:: python

    def¬†off():
    ¬†¬†¬†¬†global¬†flag
    ¬†¬†¬†¬†flag¬†=¬†0
    ¬†¬†¬†¬†Buzz.stop()
    ¬†¬†¬†¬†GPIO.output(ALedPin,GPIO.LOW)
    ¬†¬†¬†¬†GPIO.output(BLedPin,GPIO.LOW)

Die Funktion ``Off()`` definiert ‚Äûflag=0‚Äú, um die Threads **ledWork** und **BuzzWork** zu beenden und dann den Summer und die LED auszuschalten.

.. code-block:: python

    def¬†main():
    ¬†¬†¬†¬†lastState=0
    ¬†¬†¬†¬†while¬†True:
    ¬†¬†¬†¬†¬†¬†¬†¬†currentState¬†=GPIO.input(switchPin)
    ¬†¬†¬†¬†¬†¬†¬†¬†if¬†currentState¬†==¬†1¬†and¬†lastState¬†==¬†0:
    ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†on()
    ¬†¬†¬†¬†¬†¬†¬†¬†elif¬†currentState¬†==¬†0¬†and¬†lastState¬†==¬†1:
    ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†off()
    ¬†¬†¬†¬†¬†¬†¬†¬†lastState=currentState

``Main()`` enth√§lt den gesamten Ablauf des Programms: Zuerst wird der Wert
des Schiebeschalters gelesen; wenn der Kippschalter nach rechts geschaltet ist (der
Wert ist 1), wird die Funktion ``on()`` aufgerufen, der Summer gibt T√∂ne aus und die rote und die gr√ºne LED blinken. Andernfalls arbeiten der Summer und die LED nicht.

Ph√§nomen-Bild
------------------------

.. image:: ../img/image267.jpeg
   :align: center