 

.. _2.1.1_py:

2.1.1 Bouton
===============

Introduction
-----------------

Dans ce projet, nous allons apprendre à allumer ou éteindre la LED en utilisant un bouton.

Composants Nécessaires
------------------------------

Pour ce projet, nous avons besoin des composants suivants.

.. image:: ../img/list_2.1.1_Button.png

Il est certainement pratique d'acheter un kit complet, voici le lien :

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom	
        - ARTICLES DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez également les acheter séparément à partir des liens ci-dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION AUX COMPOSANTS
        - LIEN D'ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|
    *   - :ref:`cpn_button`
        - |link_button_buy|

Schéma de Principe
---------------------

Utilisez un bouton normalement ouvert comme entrée du Raspberry Pi, la connexion est montrée dans 
le schéma ci-dessous. Lorsque le bouton est enfoncé, le GPIO18 passe au niveau bas (0V). 
Nous pouvons détecter l'état du GPIO18 par programmation. C'est-à-dire que si le GPIO18 passe 
au niveau bas, cela signifie que le bouton est enfoncé. Vous pouvez exécuter le code correspondant 
lorsque le bouton est enfoncé, et alors la LED s'allumera.

.. note::
    La broche la plus longue de la LED est l'anode et la plus courte est la cathode.

.. image:: ../img/image302.png


.. image:: ../img/image303.png

Procédures Expérimentales
---------------------------

**Étape 1 :** Construisez le circuit.

.. image:: ../img/image152.png

**Étape 2 :** Ouvrez le fichier de code.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/python

**Étape 3 :** Exécutez le code.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 2.1.1_Button.py

Maintenant, appuyez sur le bouton, et la LED s'allumera ; appuyez à nouveau sur le bouton et la 
LED s'éteindra. En même temps, l'état de la LED sera affiché à l'écran.

**Code**

.. note::

    Vous pouvez **Modifier/Réinitialiser/Copier/Exécuter/Arrêter** le code ci-dessous. Mais avant cela, vous devez vous rendre dans le chemin du code source comme ``raphael-kit/python``. Après avoir modifié le code, vous pouvez l'exécuter directement pour voir l'effet.


.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time
    LedPin = 17  # Set GPIO17 as LED pin
    BtnPin = 18  # Set GPIO18 as button pin

    # Set Led status to True(OFF)
    Led_status = True

    # Define a setup function for some setup
    def setup():
        # Set the GPIO modes to BCM Numbering
        GPIO.setmode(GPIO.BCM)
        # Set LedPin's mode to output,
        # and initial level to high (3.3v)
        GPIO.setup(LedPin, GPIO.OUT, initial=GPIO.HIGH)
        # Set BtnPin's mode to input,
        # and pull up to high (3.3V)
        GPIO.setup(BtnPin, GPIO.IN)
    

    # Define a callback function for button callback
    def swLed(ev=None):
        global Led_status
        # Switch led status(on-->off; off-->on)
        Led_status = not Led_status
        GPIO.output(LedPin, Led_status)
        if Led_status:
            print ('LED OFF...')
        else:
            print ('...LED ON')

    # Define a main function for main process
    def main():
    # Set up a falling detect on BtnPin,
        # and callback function to swLed
        GPIO.add_event_detect(BtnPin, GPIO.FALLING, callback=swLed)
        while True:
            # Don't do anything.
            time.sleep(1)

    # Define a destroy function for clean up everything after
    # the script finished
    def destroy():
        # Turn off LED
        GPIO.output(LedPin, GPIO.HIGH)
        # Release resource
        GPIO.cleanup()

    # If run this script directly, do:
    if __name__ == '__main__':
        setup()
        try:
            main()
        # When 'Ctrl+C' is pressed, the program
        # destroy() will be executed.
        except KeyboardInterrupt:
            destroy()

**Explication du Code**

.. code-block:: python

    LedPin = 17

Définir GPIO17 comme broche LED

.. code-block:: python

    BtnPin = 18

Définir GPIO18 comme broche du bouton

.. code-block:: python

    GPIO.add_event_detect(BtnPin, GPIO.FALLING, callback=swLed)

Configurer une détection de chute sur BtnPin, et lorsque la valeur de BtnPin
passe d'un niveau haut à un niveau bas, cela signifie que le bouton est
enfoncé. L'étape suivante est d'appeler la fonction swLed.

.. code-block:: python

    def swLed(ev=None):
    global Led_status
    # Switch led status(on-->off; off-->on)
    Led_status = not Led_status
    GPIO.output(LedPin, Led_status)

Définir une fonction de rappel comme rappel du bouton. Lorsque le bouton est
pressé pour la première fois et que la condition not Led_status est fausse,
la fonction GPIO.output() est appelée pour allumer la LED. Lorsque le bouton est
à nouveau enfoncé, l'état de la LED sera converti de faux à vrai, donc la LED s'éteindra.

Image du Phénomène
^^^^^^^^^^^^^^^^^^^^

.. image:: ../img/image153.jpeg


