.. _2.1.1_py:

2.1.1 Knopf
===============

Einführung
-----------------

In diesem Projekt lernen wir, wie wir mit einem Knopf die LED ein- oder ausschalten können.

Benötigte Komponenten
------------------------------

Für dieses Projekt benötigen wir die folgenden Komponenten.

.. image:: ../img/list_2.1.1_Button.png

Es ist definitiv praktisch, ein ganzes Set zu kaufen, hier ist der Link:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Name	
        - ARTIKEL IN DIESEM KIT
        - LINK
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

Sie können sie auch einzeln über die untenstehenden Links kaufen.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - KOMPONENTENBESCHREIBUNG
        - KAUF-LINK

    *   - :ref:`cpn_gpio_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|
    *   - :ref:`cpn_button`
        - |link_button_buy|

Schaltplan
---------------------

Verwenden Sie einen normalerweise offenen Knopf als Eingang für den Raspberry Pi, die Verbindung wird im untenstehenden Schaltbild gezeigt. Wenn der Knopf gedrückt wird, wird GPIO18 auf ein niedriges Niveau (0V) wechseln. Durch Programmierung können wir den Zustand von GPIO18 erkennen. Das heißt, wenn GPIO18 auf ein niedriges Niveau wechselt, bedeutet dies, dass der Knopf gedrückt wurde. Sie können den entsprechenden Code ausführen, wenn der Knopf gedrückt wird, und dann wird die LED aufleuchten.

.. note::
    Der längere Pin der LED ist die Anode und der kürzere ist die Kathode.

.. image:: ../img/image302.png

.. image:: ../img/image303.png

Experimentelle Verfahren
----------------------------

**Schritt 1**: Schalten Sie den Stromkreis.

.. image:: ../img/image152.png

**Schritt 2**: Öffnen Sie die Code-Datei.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/python

**Schritt 3**: Führen Sie den Code aus.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 2.1.1_Button.py

Jetzt drücken Sie den Knopf, und die LED wird aufleuchten; drücken Sie den Knopf erneut, und die LED wird erlöschen. Gleichzeitig wird der Zustand der LED auf dem Bildschirm angezeigt.

**Code**

.. note::

    Sie können den untenstehenden Code **Modifizieren/Zurücksetzen/Kopieren/Ausführen/Stoppen**. Bevor Sie das tun, müssen Sie jedoch zum Quellcode-Pfad wie ``raphael-kit/python`` navigieren. Nach der Modifikation können Sie ihn direkt ausführen, um das Ergebnis zu sehen.


.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time
    LedPin = 17  # Set GPIO17 as LED pin
    BtnPin = 18  # Set GPIO18 as button pin

    # Set Led status to True(OFF)
    Led_status = True

    # Define a setup function for some setup
    def setup():
        # Set the GPIO modes to BCM Numbering
        GPIO.setmode(GPIO.BCM)
        # Set LedPin's mode to output,
        # and initial level to high (3.3v)
        GPIO.setup(LedPin, GPIO.OUT, initial=GPIO.HIGH)
        # Set BtnPin's mode to input,
        # and pull up to high (3.3V)
        GPIO.setup(BtnPin, GPIO.IN)
    

    # Define a callback function for button callback
    def swLed(ev=None):
        global Led_status
        # Switch led status(on-->off; off-->on)
        Led_status = not Led_status
        GPIO.output(LedPin, Led_status)
        if Led_status:
            print ('LED OFF...')
        else:
            print ('...LED ON')

    # Define a main function for main process
    def main():
    # Set up a falling detect on BtnPin,
        # and callback function to swLed
        GPIO.add_event_detect(BtnPin, GPIO.FALLING, callback=swLed)
        while True:
            # Don't do anything.
            time.sleep(1)

    # Define a destroy function for clean up everything after
    # the script finished
    def destroy():
        # Turn off LED
        GPIO.output(LedPin, GPIO.HIGH)
        # Release resource
        GPIO.cleanup()

    # If run this script directly, do:
    if __name__ == '__main__':
        setup()
        try:
            main()
        # When 'Ctrl+C' is pressed, the program
        # destroy() will be executed.
        except KeyboardInterrupt:
            destroy()

**Code-Erklärung**

.. code-block:: python

    LedPin = 17

Setze GPIO17 als LED-Pin.

.. code-block:: python

    BtnPin = 18

Setze GPIO18 als Tasten-Pin.

.. code-block:: python

    GPIO.add_event_detect(BtnPin, GPIO.FALLING, callback=swLed)

Richte eine fallende Erkennung am BtnPin ein. Wenn der Wert von BtnPin von einem hohen auf ein niedriges Niveau wechselt, bedeutet dies, dass die Taste gedrückt wird. Der nächste Schritt ist der Aufruf der Funktion swled.

.. code-block:: python

    def swLed(ev=None):
    global Led_status
    # Switch led status(on-->off; off-->on)
    Led_status = not Led_status
    GPIO.output(LedPin, Led_status)

Definiere eine Rückruffunktion als Tasten-Rückruf. Wenn die Taste das erste Mal gedrückt wird und die Bedingung, not Led_status, falsch ist, wird die Funktion GPIO.output() aufgerufen, um die LED zu beleuchten. Wenn die Taste erneut gedrückt wird, ändert sich der Zustand der LED von falsch zu wahr, sodass die LED erlischt.

Phänomen-Bild
--------------------

.. image:: ../img/image153.jpeg


