 
.. _2.2.3_py:

2.2.3 DHT-11
===============

Introduction
---------------

Le capteur de température et d'humidité numérique DHT11 est un capteur composite qui contient une 
sortie de signal numérique calibrée de température et d'humidité. La technologie de collecte de 
modules numériques dédiés et la technologie de détection de température et d'humidité sont 
appliquées pour garantir que le produit possède une haute fiabilité et une excellente stabilité.

Les capteurs incluent un capteur résistif d'élément humide et un capteur de température NTC et ils 
sont connectés à un microcontrôleur 8 bits haute performance.

Composants Nécessaires
------------------------

Pour ce projet, nous avons besoin des composants suivants :

.. image:: ../img/list_2.2.3_dht-11.png

Il est très pratique d'acheter un kit complet, voici le lien :

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom
        - ÉLÉMENTS DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez également les acheter séparément via les liens ci-dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION DES COMPOSANTS
        - LIEN D'ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_humiture_sensor`
        - |link_humiture_buy|

Schéma Électrique
----------------------

.. image:: ../img/image326.png


Procédures Expérimentales
-------------------------

**Étape 1 :** Construire le circuit.

.. image:: ../img/image207.png

**Étape 2 :** Aller dans le dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python/

**Étape 3 :** Exécuter le fichier exécutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.2.3_DHT.py

Après l'exécution du code, le programme affichera la température et l'humidité détectées par 
le DHT11 sur l'écran de l'ordinateur.

**Code**

.. note::

    Vous pouvez **Modifier/Réinitialiser/Copier/Exécuter/Arrêter** le code ci-dessous. Mais avant cela, vous devez accéder au chemin du code source comme ``raphael-kit/python``. Après avoir modifié le code, vous pouvez l'exécuter directement pour voir l'effet.

.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time

    dhtPin = 17

    GPIO.setmode(GPIO.BCM)

    MAX_UNCHANGE_COUNT = 100

    STATE_INIT_PULL_DOWN = 1
    STATE_INIT_PULL_UP = 2
    STATE_DATA_FIRST_PULL_DOWN = 3
    STATE_DATA_PULL_UP = 4
    STATE_DATA_PULL_DOWN = 5

    def readDht11():
        GPIO.setup(dhtPin, GPIO.OUT)
        GPIO.output(dhtPin, GPIO.HIGH)
        time.sleep(0.05)
        GPIO.output(dhtPin, GPIO.LOW)
        time.sleep(0.02)
        GPIO.setup(dhtPin, GPIO.IN, GPIO.PUD_UP)

        unchanged_count = 0
        last = -1
        data = []
        while True:
            current = GPIO.input(dhtPin)
            data.append(current)
            if last != current:
                unchanged_count = 0
                last = current
            else:
                unchanged_count += 1
                if unchanged_count > MAX_UNCHANGE_COUNT:
                    break

        state = STATE_INIT_PULL_DOWN

        lengths = []
        current_length = 0

        for current in data:
            current_length += 1

            if state == STATE_INIT_PULL_DOWN:
                if current == GPIO.LOW:
                    state = STATE_INIT_PULL_UP
                else:
                    continue
            if state == STATE_INIT_PULL_UP:
                if current == GPIO.HIGH:
                    state = STATE_DATA_FIRST_PULL_DOWN
                else:
                    continue
            if state == STATE_DATA_FIRST_PULL_DOWN:
                if current == GPIO.LOW:
                    state = STATE_DATA_PULL_UP
                else:
                    continue
            if state == STATE_DATA_PULL_UP:
                if current == GPIO.HIGH:
                    current_length = 0
                    state = STATE_DATA_PULL_DOWN
                else:
                    continue
            if state == STATE_DATA_PULL_DOWN:
                if current == GPIO.LOW:
                    lengths.append(current_length)
                    state = STATE_DATA_PULL_UP
                else:
                    continue
        if len(lengths) != 40:
            #print ("Data not good, skip")
            return False

        shortest_pull_up = min(lengths)
        longest_pull_up = max(lengths)
        halfway = (longest_pull_up + shortest_pull_up) / 2
        bits = []
        the_bytes = []
        byte = 0

        for length in lengths:
            bit = 0
            if length > halfway:
                bit = 1
            bits.append(bit)
        #print ("bits: %s, length: %d" % (bits, len(bits)))
        for i in range(0, len(bits)):
            byte = byte << 1
            if (bits[i]):
                byte = byte | 1
            else:
                byte = byte | 0
            if ((i + 1) % 8 == 0):
                the_bytes.append(byte)
                byte = 0
        #print (the_bytes)
        checksum = (the_bytes[0] + the_bytes[1] + the_bytes[2] + the_bytes[3]) & 0xFF
        if the_bytes[4] != checksum:
            #print ("Data not good, skip")
            return False

        return the_bytes[0], the_bytes[2]

    def main():

        while True:
            result = readDht11()
            if result:
                humidity, temperature = result
                print ("humidity: %s %%,  Temperature: %s ℃" % (humidity, temperature))
            time.sleep(1)

    def destroy():
        GPIO.cleanup()

    if __name__ == '__main__':
        try:
            main()
        except KeyboardInterrupt:
            destroy()

**Explication du Code**

.. code-block:: python

    def readDht11():
        GPIO.setup(dhtPin, GPIO.OUT)
        GPIO.output(dhtPin, GPIO.HIGH)
        time.sleep(0.05)
        GPIO.output(dhtPin, GPIO.LOW)
        time.sleep(0.02)
        GPIO.setup(dhtPin, GPIO.IN, GPIO.PUD_UP)
        unchanged_count = 0
        last = -1
        data = []
        #...

Cette fonction est utilisée pour implémenter les fonctions du DHT11. Elle stocke les données 
détectées dans le tableau the_bytes[]. Le DHT11 transmet des données de 40 bits à la fois. 
Les 16 premiers bits sont liés à l'humidité, les 16 bits du milieu sont liés à la température, 
et les huit derniers bits sont utilisés pour la vérification. 


Le format des données est le suivant :

**8 bits de données entières d'humidité** +\ **8 bits de données décimales d'humidité** 
+\**8 bits de données entières de température** + **8 bits de données décimales de température** 
+ **8 bits de bit de contrôle**.

Lorsque la validité est détectée via le bit de contrôle, la fonction renvoie 
deux résultats : 1. erreur ; 2. humidité et température.

.. code-block:: python

    checksum = (the_bytes[0] + the_bytes[1] + the_bytes[2] + the_bytes[3]) & 0xFF
    if the_bytes[4] != checksum:
        #print ("Data not good, skip")
        return False

    return the_bytes[0], the_bytes[2]

Par exemple, si les données reçues sont 00101011 (valeur de 8 bits de l'entier d'humidité) 
00000000 (valeur de 8 bits de la décimale d'humidité) 00111100 (valeur de 8 bits de l'entier 
de température) 00000000 (valeur de 8 bits de la décimale de température) 01100111 (bit de contrôle)

**Calcul :**

00101011+00000000+00111100+00000000=01100111.

Si le résultat final est égal aux données du bit de contrôle, la transmission des données est 
anormale : retour False.

Si le résultat final est égal aux données du bit de contrôle, les données reçues sont correctes, 
alors il y aura un retour de the_bytes[0] et the_bytes[2] et l'affichage 
"Humidité = 43%, Température = 60℃".

Image du Phénomène
------------------------

.. image:: ../img/image209.jpeg