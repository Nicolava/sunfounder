.. _2.2.3_py:

2.2.3 DHT-11
===============

はじめに
--------------

DHT11はデジタル温湿度センサであり、キャリブレートされたデジタル信号出力を持つ複合センサーです。専用のデジタルモジュールの収集技術と温湿度センシング技術が採用されており、高い信頼性と優れた安定性を確保しています。

このセンサには、湿素抵抗センサとNTC温度センサが含まれており、高性能8ビットマイクロコントローラに接続されています。

必要な部品
------------------------------

このプロジェクトでは、以下のコンポーネントが必要です。

.. image:: ../img/list_2.2.3_dht-11.png

全体のキットを購入するのが便利です、リンクは以下です：

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - 名前
        - このキットのアイテム
        - リンク
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

以下のリンクから個々のコンポーネントも購入できます。

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - コンポーネントの紹介
        - 購入リンク

    *   - :ref:`cpn_gpio_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_humiture_sensor`
        - |link_humiture_buy|

回路図
-----------------

.. image:: ../img/image326.png

実験手順
-----------------------

**ステップ1：** 回路を組み立てます。

.. image:: ../img/image207.png

**ステップ2：** コードのフォルダに移動します。

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python/

**ステップ3：** 実行可能ファイルを実行します。

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.2.3_DHT.py

コードが実行された後、DHT11が検出した温度と湿度がコンピュータ画面に表示されます。

**コード**

.. note::

    下のコードは **編集/リセット/コピー/実行/停止** ができますが、それ以前に ``raphael-kit/python`` のようなソースコードのパスに移動する必要があります。コードを修正した後、その効果を直接確認するために実行できます。

.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time

    dhtPin = 17

    GPIO.setmode(GPIO.BCM)

    MAX_UNCHANGE_COUNT = 100

    STATE_INIT_PULL_DOWN = 1
    STATE_INIT_PULL_UP = 2
    STATE_DATA_FIRST_PULL_DOWN = 3
    STATE_DATA_PULL_UP = 4
    STATE_DATA_PULL_DOWN = 5

    def readDht11():
        GPIO.setup(dhtPin, GPIO.OUT)
        GPIO.output(dhtPin, GPIO.HIGH)
        time.sleep(0.05)
        GPIO.output(dhtPin, GPIO.LOW)
        time.sleep(0.02)
        GPIO.setup(dhtPin, GPIO.IN, GPIO.PUD_UP)

        unchanged_count = 0
        last = -1
        data = []
        while True:
            current = GPIO.input(dhtPin)
            data.append(current)
            if last != current:
                unchanged_count = 0
                last = current
            else:
                unchanged_count += 1
                if unchanged_count > MAX_UNCHANGE_COUNT:
                    break

        state = STATE_INIT_PULL_DOWN

        lengths = []
        current_length = 0

        for current in data:
            current_length += 1

            if state == STATE_INIT_PULL_DOWN:
                if current == GPIO.LOW:
                    state = STATE_INIT_PULL_UP
                else:
                    continue
            if state == STATE_INIT_PULL_UP:
                if current == GPIO.HIGH:
                    state = STATE_DATA_FIRST_PULL_DOWN
                else:
                    continue
            if state == STATE_DATA_FIRST_PULL_DOWN:
                if current == GPIO.LOW:
                    state = STATE_DATA_PULL_UP
                else:
                    continue
            if state == STATE_DATA_PULL_UP:
                if current == GPIO.HIGH:
                    current_length = 0
                    state = STATE_DATA_PULL_DOWN
                else:
                    continue
            if state == STATE_DATA_PULL_DOWN:
                if current == GPIO.LOW:
                    lengths.append(current_length)
                    state = STATE_DATA_PULL_UP
                else:
                    continue
        if len(lengths) != 40:
            #print ("Data not good, skip")
            return False

        shortest_pull_up = min(lengths)
        longest_pull_up = max(lengths)
        halfway = (longest_pull_up + shortest_pull_up) / 2
        bits = []
        the_bytes = []
        byte = 0

        for length in lengths:
            bit = 0
            if length > halfway:
                bit = 1
            bits.append(bit)
        #print ("bits: %s, length: %d" % (bits, len(bits)))
        for i in range(0, len(bits)):
            byte = byte << 1
            if (bits[i]):
                byte = byte | 1
            else:
                byte = byte | 0
            if ((i + 1) % 8 == 0):
                the_bytes.append(byte)
                byte = 0
        #print (the_bytes)
        checksum = (the_bytes[0] + the_bytes[1] + the_bytes[2] + the_bytes[3]) & 0xFF
        if the_bytes[4] != checksum:
            #print ("Data not good, skip")
            return False

        return the_bytes[0], the_bytes[2]

    def main():

        while True:
            result = readDht11()
            if result:
                humidity, temperature = result
                print ("humidity: %s %%,  Temperature: %s ℃" % (humidity, temperature))
            time.sleep(1)

    def destroy():
        GPIO.cleanup()

    if __name__ == '__main__':
        try:
            main()
        except KeyboardInterrupt:
            destroy() 

**コード説明**

.. code-block:: python

    def readDht11():
        GPIO.setup(dhtPin, GPIO.OUT)
        GPIO.output(dhtPin, GPIO.HIGH)
        time.sleep(0.05)
        GPIO.output(dhtPin, GPIO.LOW)
        time.sleep(0.02)
        GPIO.setup(dhtPin, GPIO.IN, GPIO.PUD_UP)
        unchanged_count = 0
        last = -1
        data = []
        #...

この関数は、DHT11の機能を実装するために使用されます。検出したデータはthe_bytes[]配列に格納されます。DHT11は一度に40ビットのデータを送信します。最初の16ビットは湿度に関連し、中央の16ビットは温度に関連し、最後の8ビットは検証に使用されます。データ形式は次の通りです：

**8ビット湿度整数データ** +\ **8ビット湿度小数データ**
+\ **8ビット温度整数データ** + **8ビット温度小数データ**
+ **8ビットチェックビット**。

チェックビットを介して有効性が確認された場合、この関数は2つの結果を返します：1. エラー; 2. 湿度と温度。

.. code-block:: python

    checksum = (the_bytes[0] + the_bytes[1] + the_bytes[2] + the_bytes[3]) & 0xFF
    if the_bytes[4] != checksum:
        #print ("Data not good, skip")
        return False

    return the_bytes[0], the_bytes[2]

例えば、受信したデータが00101011（湿度整数の8ビット値）、00000000（湿度小数の8ビット値）、00111100（温度整数の8ビット値）、00000000（温度小数の8ビット値）、01100111（チェックビット）の場合、

**計算：**

00101011+00000000+00111100+00000000=01100111。

最終結果がチェックビットデータと等しい場合、データ送信は異常です：Falseを返します。

最終結果がチェックビットデータと等しい場合、受信データは正確であり、the_bytes[0]とthe_bytes[2]を返して、「湿度=43%、温度=60C」と出力します。

現象の画像
------------------

.. image:: ../img/image209.jpeg