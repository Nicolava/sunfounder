 
.. _4.1.9_py:

4.1.9 Alerte de Recul
======================================

Introduction
-------------

Dans ce projet, nous allons utiliser un écran LCD, un buzzer et des capteurs ultrasoniques 
pour créer un système d'assistance au recul. Nous pouvons le placer sur un véhicule télécommandé 
pour simuler le processus réel de recul d'une voiture dans un garage.


Composants Nécessaires
------------------------------

Dans ce projet, nous avons besoin des composants suivants.

.. image:: ../img/list_Reversing_Alarm.png
    :align: center

Il est certainement pratique d'acheter un kit complet, voici le lien : 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom	
        - ÉLÉMENTS DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez également les acheter séparément à partir des liens ci-dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION DES COMPOSANTS
        - LIEN D'ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_buzzer`
        - \-
    *   - :ref:`cpn_transistor`
        - |link_transistor_buy|
    *   - :ref:`cpn_ultrasonic_sensor`
        - |link_ultrasonic_buy|
    *   - :ref:`cpn_i2c_lcd`
        - |link_i2clcd1602_buy|

Schéma de Câblage
--------------------

Le capteur ultrasonique détecte la distance entre lui-même et l'obstacle qui sera affichée 
sur l'écran LCD sous forme de code. En même temps, le capteur ultrasonique fait émettre au 
buzzer un son d'alerte de fréquence différente en fonction de la valeur de la distance.

=============== ======== ======== ===
Nom de la Carte Brochage wiringPi BCM
GPIO23          Pin 16   4        23
GPIO24          Pin 18   5        24
GPIO17          Pin 11            17
SDA1            Pin 3               
SCL1            Pin 5               
=============== ======== ======== ===

.. image:: ../img/Schematic_three_one3.png
   :align: center

Procédures Expérimentales
------------------------------

**Étape 1 :** Construisez le circuit.

.. image:: ../img/image242.png
    :width: 400
    :align: center

**Étape 2 :** Changez de répertoire.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python/

**Étape 3 :** Exécutez.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 4.1.9_ReversingAlarm.py

Pendant l'exécution du code, le module de capteur ultrasonique détecte la distance 
par rapport à l'obstacle et affiche l'information sur l'écran LCD1602. De plus, 
le buzzer émet un son d'avertissement dont la fréquence varie en fonction de la distance.

.. note::

    * Si vous obtenez l'erreur ``FileNotFoundError: [Errno 2] No such file or directory: '/dev/i2c-1'``, vous devez vous référer à :ref:`i2c_config` pour activer l'I2C.
    * Si vous obtenez l'erreur ``ModuleNotFoundError: No module named 'smbus2'``, veuillez exécuter ``sudo pip3 install smbus2``.
    * Si l'erreur ``OSError: [Errno 121] Remote I/O error`` apparaît, cela signifie que le module est mal câblé ou défectueux.
    * Si le code et le câblage sont corrects mais que l'écran LCD n'affiche toujours pas de contenu, vous pouvez tourner le potentiomètre à l'arrière pour augmenter le contraste.

**Code**

.. note::
    Vous pouvez **Modifier/Réinitialiser/Copier/Exécuter/Arrêter** le code ci-dessous. Mais avant cela, vous devez aller dans le chemin du code source comme ``raphael-kit/python``. Après avoir modifié le code, vous pouvez l'exécuter directement pour voir l'effet.

.. raw:: html

    <run></run>

.. code-block:: python

    import LCD1602
    import time
    import RPi.GPIO as GPIO

    TRIG = 16
    ECHO = 18
    BUZZER = 11

    def lcdsetup():
    LCD1602.init(0x27, 1)   # init(slave address, background light)
        LCD1602.clear()   
        LCD1602.write(0, 0, 'Ultrasonic Starting')
        LCD1602.write(1, 1, 'By SunFounder')
        time.sleep(2)

    def setup():
        GPIO.setmode(GPIO.BOARD)
        GPIO.setup(TRIG, GPIO.OUT)
        GPIO.setup(ECHO, GPIO.IN)
        GPIO.setup(BUZZER, GPIO.OUT, initial=GPIO.LOW)
        lcdsetup()

    def distance():
        GPIO.output(TRIG, 0)
        time.sleep(0.000002)

        GPIO.output(TRIG, 1)
        time.sleep(0.00001)
        GPIO.output(TRIG, 0)

        while GPIO.input(ECHO) == 0:
            a = 0
        time1 = time.time()
        while GPIO.input(ECHO) == 1:
            a = 1
        time2 = time.time()

        during = time2 - time1
        return during * 340 / 2 * 100

    def destroy():
        GPIO.output(BUZZER, GPIO.LOW)
        GPIO.cleanup()
        LCD1602.clear()

    def loop():
        while True:
            dis = distance()
        print (dis, 'cm')
        print ('')
            GPIO.output(BUZZER, GPIO.LOW)
        if (dis > 400):
                LCD1602.clear()
            LCD1602.write(0, 0, 'Error')
            LCD1602.write(3, 1, 'Out of range')
                time.sleep(0.5)
            else:
                LCD1602.clear()
            LCD1602.write(0, 0, 'Distance is')
            LCD1602.write(5, 1, str(round(dis,2)) +' cm')
            if(dis>=50):
                    time.sleep(0.5)
            elif(dis<50 and dis>20):
                for i in range(0,2,1):
                        GPIO.output(BUZZER, GPIO.HIGH)
                        time.sleep(0.05)
                        GPIO.output(BUZZER, GPIO.LOW)
                        time.sleep(0.2)
            elif(dis<=20):
                for i in range(0,5,1):
                        GPIO.output(BUZZER, GPIO.HIGH)
                        time.sleep(0.05)
                        GPIO.output(BUZZER, GPIO.LOW)
                        time.sleep(0.05)


    if __name__ == "__main__":
        setup()
        try:
            loop()
        except KeyboardInterrupt:
            destroy()


**Explication du Code**

.. code-block:: python

    def lcdsetup():
        LCD1602.init(0x27, 1)   # init(slave address, background light)

    def setup():
        GPIO.setmode(GPIO.BOARD)
        GPIO.setup(TRIG, GPIO.OUT)
        GPIO.setup(ECHO, GPIO.IN)
        GPIO.setup(BUZZER, GPIO.OUT, initial=GPIO.LOW)
        lcdsetup()

Dans ce programme, nous appliquons de manière synthétique les composants utilisés précédemment. 
Ici, nous utilisons des buzzers, un écran LCD et un capteur ultrasonique. Nous pouvons les 
initialiser de la même manière que nous l'avons fait auparavant.

.. code-block:: python

    dis = distance()
    print (dis, 'cm')
    print ('')
    GPIO.output(BUZZER, GPIO.LOW)
    if (dis > 400):
        LCD1602.clear()
        LCD1602.write(0, 0, 'Error')
        LCD1602.write(3, 1, 'Out of range')
        time.sleep(0.5)
    else:
        LCD1602.clear()
        LCD1602.write(0, 0, 'Distance is')
        LCD1602.write(5, 1, str(round(dis,2)) +' cm')

Ici, nous obtenons les valeurs du capteur ultrasonique et calculons la distance. Si la valeur 
de la distance est supérieure à la plage de détection, un message d'erreur est affiché sur 
l'écran LCD. Si la distance est dans la plage de fonctionnement, les résultats correspondants 
seront affichés.

.. code-block:: python

    LCD1602.write(5, 1, str(round(dis,2)) +' cm')

Étant donné que la sortie LCD ne prend en charge que les types de caractères, nous devons 
utiliser **str()** pour convertir les valeurs numériques en caractères. Nous allons arrondir 
à deux décimales.

.. code-block:: python

    if(dis>=50):
        time.sleep(0.5)
    elif(dis<50 and dis>20):
        for i in range(0,2,1):
            GPIO.output(BUZZER, GPIO.HIGH)
            time.sleep(0.05)
            GPIO.output(BUZZER, GPIO.LOW)
            time.sleep(0.2)
    elif(dis<=20):
        for i in range(0,5,1):
            GPIO.output(BUZZER, GPIO.HIGH)
            time.sleep(0.05)
            GPIO.output(BUZZER, GPIO.LOW)
            time.sleep(0.05)

Cette condition de jugement est utilisée pour contrôler le son du buzzer. Selon la différence 
de distance, elle peut être divisée en trois cas, chacun ayant des fréquences sonores différentes. 
Étant donné que la valeur totale du délai est de 500, toutes peuvent fournir un intervalle de 
500 ms pour le fonctionnement du capteur ultrasonique.


Photo du Phénomène
--------------------

.. image:: ../img/image243.jpeg
   :align: center