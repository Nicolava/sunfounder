.. _4.1.9_py:

4.1.9 Rückwärts-Alarm
======================================

Einführung
-------------

In diesem Projekt nutzen wir ein LCD, einen Buzzer und Ultraschallsensoren, um ein System zur Unterstützung beim Rückwärtsfahren zu erstellen. Dies kann auf ein ferngesteuertes Fahrzeug gesetzt werden, um den realen Vorgang des Rückwärtsfahrens eines Autos in die Garage zu simulieren.

Benötigte Komponenten
------------------------------

Für dieses Projekt benötigen wir folgende Komponenten.

.. image:: ../img/list_Reversing_Alarm.png
    :align: center

Es ist sicherlich praktisch, ein komplettes Set zu kaufen. Hier ist der Link dazu:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Name
        - ARTIKEL IN DIESEM KIT
        - LINK
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

Sie können diese auch einzeln über die untenstehenden Links kaufen.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - KOMPONENTENBESCHREIBUNG
        - KAUF-LINK

    *   - :ref:`cpn_gpio_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_buzzer`
        - \-
    *   - :ref:`cpn_transistor`
        - |link_transistor_buy|
    *   - :ref:`cpn_ultrasonic_sensor`
        - |link_ultrasonic_buy|
    *   - :ref:`cpn_i2c_lcd1602`
        - |link_i2clcd1602_buy|

Schaltplan
--------------------

Der Ultraschallsensor misst den Abstand zwischen sich und dem Hindernis, welcher in Form von Code auf dem LCD angezeigt wird. Gleichzeitig gibt der Ultraschallsensor über den Buzzer einen Hinweiston unterschiedlicher Frequenz je nach gemessenem Abstandswert aus.

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO23       Pin 16   4        23
GPIO24       Pin 18   5        24
GPIO17       Pin 11   0        17
SDA1         Pin 3             
SCL1         Pin 5             
============ ======== ======== ===

.. image:: ../img/Schematic_three_one3.png
   :align: center

Experimentelle Verfahren
------------------------

**Schritt 1:** Schaltung aufbauen.

.. image:: ../img/image242.png
    :width: 400
    :align: center

**Schritt 2:** Verzeichnis wechseln.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python/

**Schritt 3:** Ausführen.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 4.1.9_ReversingAlarm.py

Während der Code läuft, misst das Ultraschall-Sensormodul den Abstand zum Hindernis und zeigt die Informationen über die Entfernung auf dem LCD1602 an. Zusätzlich gibt der Buzzer einen Warnton aus, dessen Frequenz sich mit dem Abstand ändert.

.. note::

    * Falls der Fehler ``FileNotFoundError: [Errno 2] No such file or directory: '/dev/i2c-1'`` auftritt, beziehen Sie sich auf :ref:`i2c_config`, um den I2C zu aktivieren.
    * Bei dem Fehler ``ModuleNotFoundError: No module named 'smbus2'`` führen Sie bitte ``sudo pip3 install smbus2`` aus.
    * Wenn der Fehler ``OSError: [Errno 121] Remote I/O error`` erscheint, bedeutet dies, dass das Modul falsch verdrahtet ist oder defekt ist.
    * Wenn der Code und die Verkabelung korrekt sind, aber das LCD dennoch keinen Inhalt anzeigt, können Sie das Potentiometer auf der Rückseite drehen, um den Kontrast zu erhöhen.

**Code**

.. note::
    Sie können den untenstehenden Code **Ändern/Zurücksetzen/Kopieren/Ausführen/Stoppen**. Zuvor müssen Sie jedoch zum Quellcodepfad wie ``raphael-kit/python`` wechseln. Nachdem Sie den Code modifiziert haben, können Sie ihn direkt ausführen, um das Ergebnis zu sehen.

.. raw:: html

    <run></run>

.. code-block:: python

    import LCD1602
    import time
    import RPi.GPIO as GPIO

    TRIG = 16
    ECHO = 18
    BUZZER = 11

    def lcdsetup():
    LCD1602.init(0x27, 1)   # init(slave address, background light)
    LCD1602.clear()   
    LCD1602.write(0, 0, 'Ultrasonic Starting')
    LCD1602.write(1, 1, 'By SunFounder')
    time.sleep(2)

    def setup():
    GPIO.setmode(GPIO.BOARD)
    GPIO.setup(TRIG, GPIO.OUT)
    GPIO.setup(ECHO, GPIO.IN)
    GPIO.setup(BUZZER, GPIO.OUT, initial=GPIO.LOW)
    lcdsetup()

    def distance():
    GPIO.output(TRIG, 0)
    time.sleep(0.000002)

    GPIO.output(TRIG, 1)
    time.sleep(0.00001)
    GPIO.output(TRIG, 0)

    while GPIO.input(ECHO) == 0:
        a = 0
    time1 = time.time()
    while GPIO.input(ECHO) == 1:
        a = 1
    time2 = time.time()

    during = time2 - time1
    return during * 340 / 2 * 100

    def destroy():
    GPIO.output(BUZZER, GPIO.LOW)
    GPIO.cleanup()
    LCD1602.clear()

    def loop():
    while True:
        dis = distance()
        print (dis, 'cm')
        print ('')
        GPIO.output(BUZZER, GPIO.LOW)
        if (dis > 400):
            LCD1602.clear()
            LCD1602.write(0, 0, 'Error')
            LCD1602.write(3, 1, 'Out of range')
            time.sleep(0.5)
        else:
            LCD1602.clear()
            LCD1602.write(0, 0, 'Distance is')
            LCD1602.write(5, 1, str(round(dis,2)) +' cm')
            if(dis>=50):
                time.sleep(0.5)
            elif(dis<50 and dis>20):
                for i in range(0,2,1):
                    GPIO.output(BUZZER, GPIO.HIGH)
                    time.sleep(0.05)
                    GPIO.output(BUZZER, GPIO.LOW)
                    time.sleep(0.2)
            elif(dis<=20):
                for i in range(0,5,1):
                    GPIO.output(BUZZER, GPIO.HIGH)
                    time.sleep(0.05)
                    GPIO.output(BUZZER, GPIO.LOW)
                    time.sleep(0.05)


    if __name__ == "__main__":
        setup()
        try:       
            loop()
        except KeyboardInterrupt:
            destroy()



**Code-Erklärung**

.. code-block:: python

    def lcdsetup():
        LCD1602.init(0x27, 1)   # init(slave address, background light)

    def setup():
        GPIO.setmode(GPIO.BOARD)
        GPIO.setup(TRIG, GPIO.OUT)
        GPIO.setup(ECHO, GPIO.IN)
        GPIO.setup(BUZZER, GPIO.OUT, initial=GPIO.LOW)
        lcdsetup()

In diesem Programm verwenden wir die zuvor genutzten Komponenten synthetisch. Hier benutzen wir Buzzer, LCD und Ultraschall. Sie können genau so initialisiert werden, wie wir es zuvor getan haben.

.. code-block:: python

    dis = distance()
    print (dis, 'cm')
    print ('')
    GPIO.output(BUZZER, GPIO.LOW)
    if (dis > 400):
        LCD1602.clear()
        LCD1602.write(0, 0, 'Error')
        LCD1602.write(3, 1, 'Out of range')
        time.sleep(0.5)
    else:
        LCD1602.clear()
        LCD1602.write(0, 0, 'Distance is')
        LCD1602.write(5, 1, str(round(dis,2)) +' cm')

Hier erfassen wir die Werte des Ultraschallsensors und berechnen die Entfernung. Wenn der Entfernungs-Wert größer ist als der erkannte Wertebereich, wird auf dem LCD eine Fehlermeldung angezeigt. Wenn die Entfernung jedoch im Arbeitsbereich liegt, werden die entsprechenden Ergebnisse ausgegeben.

.. code-block:: python

    LCD1602.write(5, 1, str(round(dis,2)) +' cm')

Da die LCD-Ausgabe nur Zeichentypen unterstützt, müssen wir **str()** verwenden, um numerische Werte in Zeichen umzuwandeln. Wir runden auf zwei Dezimalstellen.

.. code-block:: python

    if(dis>=50):
        time.sleep(0.5)
    elif(dis<50 and dis>20):
        for i in range(0,2,1):
            GPIO.output(BUZZER, GPIO.HIGH)
            time.sleep(0.05)
            GPIO.output(BUZZER, GPIO.LOW)
            time.sleep(0.2)
    elif(dis<=20):
        for i in range(0,5,1):
            GPIO.output(BUZZER, GPIO.HIGH)
            time.sleep(0.05)
            GPIO.output(BUZZER, GPIO.LOW)
            time.sleep(0.05)

Diese Abfragebedingung wird verwendet, um den Klang des Buzzers zu steuern. Je nach Entfernungsunterschied gibt es drei Fälle, in denen unterschiedliche Tonfrequenzen vorkommen. Da der Gesamtwert der Verzögerung 500 beträgt, können alle einen 500ms-Intervall für die Arbeit des Ultraschallsensors bereitstellen.

Phänomen-Bild
--------------------

.. image:: ../img/image243.jpeg
   :align: center