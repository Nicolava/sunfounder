 
.. _1.1.4_py:

1.1.4 Affichage à 7 segments
==================================

Introduction
-------------------

Essayons de piloter un afficheur à 7 segments pour afficher un chiffre de 0 à 9 et de A à F.

Composants nécessaires
--------------------------------

Dans ce projet, nous avons besoin des composants suivants.

.. image:: ../img/list_7_segment.png

Il est certainement pratique d'acheter un kit complet, voici le lien :

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom	
        - ÉLÉMENTS DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez également les acheter séparément via les liens ci-dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION AUX COMPOSANTS
        - LIEN D'ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_7_segment`
        - |link_7segment_buy|
    *   - :ref:`cpn_74hc595`
        - |link_74hc595_buy|


Schéma de connexion
------------------------

Connectez la broche ST_CP du 74HC595 au GPIO18 du Raspberry Pi, SH_CP au GPIO27, DS au GPIO17, 
et les ports de sortie parallèles aux 8 segments de l'afficheur LED. Les données d'entrée dans 
la broche DS sont envoyées au registre de décalage lorsque SH_CP (l'entrée d'horloge du registre 
de décalage) est sur le front montant, et au registre de mémoire lorsque ST_CP (l'entrée d'horloge 
de la mémoire) est sur le front montant. Ensuite, vous pouvez contrôler les états de SH_CP et de 
ST_CP via les GPIOs du Raspberry Pi pour transformer l'entrée de données série en sortie de données 
parallèles afin d'économiser les GPIOs du Raspberry Pi et de piloter l'affichage.

============ ======== ======== ===
Nom T-Board  Physique wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
============ ======== ======== ===

.. image:: ../img/schematic_7_segment.png

Procédures expérimentales
------------------------------

**Étape 1 :** Construisez le circuit.

.. image:: ../img/image73.png

**Étape 2 :** Accédez au dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python/

**Étape 3 :** Exécutez.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 1.1.4_7-Segment.py

Après l'exécution du code, vous verrez l'affichage à 7 segments afficher les chiffres de 0 à 9, puis de A à F.

**Code**

.. note::
    Vous pouvez **Modifier/Réinitialiser/Copier/Exécuter/Arrêter** le code ci-dessous. Mais avant cela, vous devez aller dans le chemin du code source comme ``raphael-kit/python``. Après avoir modifié le code, vous pouvez l'exécuter directement pour voir l'effet. Après avoir confirmé qu'il n'y a pas de problèmes, vous pouvez utiliser le bouton Copier pour copier le code modifié, puis ouvrir le code source dans Terminal via la commande ``nano`` et le coller.

.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time

    # Configuration des broches
    SDI   = 17
    RCLK  = 18
    SRCLK = 27

    # Define a segment code from 0 to F in Hexadecimal
    segCode = [0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71]

    def setup():
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(SDI, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(RCLK, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(SRCLK, GPIO.OUT, initial=GPIO.LOW)

    # Shift the data to 74HC595
    def hc595_shift(dat):
        for bit in range(0, 8): 
            GPIO.output(SDI, 0x80 & (dat << bit))
            GPIO.output(SRCLK, GPIO.HIGH)
            time.sleep(0.001)
            GPIO.output(SRCLK, GPIO.LOW)
        GPIO.output(RCLK, GPIO.HIGH)
        time.sleep(0.001)
        GPIO.output(RCLK, GPIO.LOW)

def main():
    while True:
            # Shift the code one by one from segCode list
        for code in segCode:
            hc595_shift(code)
                print ("segCode[%s]: 0x%02X"%(segCode.index(code), code)) # %02X means double digit HEX to print
            time.sleep(0.5)

def destroy():
    GPIO.cleanup()

if __name__ == '__main__':
    setup()
    try:
        main()
    except KeyboardInterrupt:
        destroy()

**Explication du Code**

.. code-block:: python

    segCode = [0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71]

Un tableau de codes de segments de 0 à F en Hexadécimal (Cathode commune).

.. code-block:: python

    def setup():
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(SDI, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(RCLK, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(SRCLK, GPIO.OUT, initial=GPIO.LOW)

Définissez les trois broches ds, st_cp, sh_cp en sortie et l'état initial à un niveau bas.

.. code-block:: python

    GPIO.output(SDI, 0x80 & (dat << bit))

Attribue les données dat à SDI(DS) par bits. Supposons ici que dat=0x3f(0011 1111), lorsque bit=2, 0x3f se décalera vers la droite (<<) de 2 bits. 1111 1100 (0x3f << 2) & 1000 0000 (0x80) = 1000 0000, est vrai.

.. code-block:: python

    GPIO.output(SRCLK, GPIO.HIGH)

La valeur initiale de SRCLK a été définie à LOW, et ici elle est définie à HIGH, ce qui permet de générer une impulsion de front montant, puis de décaler les données DS vers le registre de décalage.

.. code-block:: python

    GPIO.output(RCLK, GPIO.HIGH)

La valeur initiale de RCLK a été définie à LOW, et ici elle est définie à HIGH, ce qui permet de générer un front montant, puis de transférer les données du registre de décalage au registre de stockage.

.. note::
    Le format hexadécimal des chiffres 0~15 est (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F)

**Image du Phénomène**

.. image:: ../img/image74.jpeg
