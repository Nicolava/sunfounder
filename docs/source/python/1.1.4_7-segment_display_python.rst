.. note::

    Ciao, benvenuto nella SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community su Facebook! Approfondisci le tue conoscenze su Raspberry Pi, Arduino ed ESP32 insieme ad altri appassionati.

    **Perch√© unirti a noi?**

    - **Supporto esperto**: Risolvi problemi post-vendita e sfide tecniche con l'aiuto della nostra comunit√† e del nostro team.
    - **Impara e condividi**: Scambia suggerimenti e tutorial per migliorare le tue competenze.
    - **Anteprime esclusive**: Ottieni accesso anticipato agli annunci di nuovi prodotti e anteprime esclusive.
    - **Sconti speciali**: Approfitta di sconti esclusivi sui nostri prodotti pi√π recenti.
    - **Promozioni festive e concorsi**: Partecipa a concorsi e promozioni durante le festivit√†.

    üëâ Sei pronto a esplorare e creare con noi? Clicca su [|link_sf_facebook|] e unisciti oggi stesso!

.. _1.1.4_py:

1.1.4 Display a 7 Segmenti
=============================

Introduzione
-----------------

Proviamo a controllare un display a 7 segmenti per visualizzare una cifra da 0 a 9 e le lettere da A a F.

Componenti Necessari
------------------------------

In questo progetto, abbiamo bisogno dei seguenti componenti. 

.. image:: ../img/list_7_segment.png

√à sicuramente comodo acquistare un kit completo, ecco il link: 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nome	
        - ARTICOLI IN QUESTO KIT
        - LINK
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Puoi anche acquistarli separatamente dai link qui sotto.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUZIONE AI COMPONENTI
        - LINK PER L'ACQUISTO

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_7_segment`
        - |link_7segment_buy|
    *   - :ref:`cpn_74hc595`
        - |link_74hc595_buy|


Schema Elettrico
---------------------

Collega il pin ST_CP del 74HC595 al GPIO18 del Raspberry Pi, SH_CP al GPIO27, DS al 
GPIO17, e le porte di uscita parallele agli 8 segmenti del display a LED. Inserisci i 
dati nel pin DS del registro a scorrimento quando SH_CP (l'ingresso di clock del registro 
a scorrimento) si trova al fronte di salita, e al registro di memoria quando ST_CP 
(l'ingresso di clock della memoria) si trova al fronte di salita. In questo modo, puoi 
controllare gli stati di SH_CP e ST_CP tramite i GPIO del Raspberry Pi per trasformare 
l'input di dati seriale in un'uscita di dati paralleli, risparmiando i GPIO del Raspberry 
Pi e pilotando il display.

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
============ ======== ======== ===

.. image:: ../img/schematic_7_segment.png


Procedure Sperimentali
------------------------------

**Passo 1:** Costruisci il circuito.

.. image:: ../img/image73.png

**Passo 2:** Vai nella cartella del codice.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python/

**Passo 3:** Esegui.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 1.1.4_7-Segment.py

Dopo l'esecuzione del codice, vedrai il display a 7 segmenti mostrare le cifre da 0 a 9 e le lettere da A a F.

**Codice**

.. note::
    Puoi **Modificare/Reimpostare/Copiare/Eseguire/Interrompere** il codice qui sotto. Ma prima devi accedere al percorso del codice come ``raphael-kit/python``. Dopo aver modificato il codice, puoi eseguirlo direttamente per vedere l'effetto. Dopo aver confermato che non ci sono problemi, puoi utilizzare il pulsante Copia per copiare il codice modificato, quindi aprire il codice sorgente in Terminale tramite il comando ``nano`` e incollarlo.

.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time

    # Configurazione dei pin
    SDI   = 17
    RCLK  = 18
    SRCLK = 27

    # Definisci un codice segmento da 0 a F in esadecimale
    segCode = [0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71]

    def setup():
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(SDI, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(RCLK, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(SRCLK, GPIO.OUT, initial=GPIO.LOW)

    # Trasmetti i dati al 74HC595
    def hc595_shift(dat):
        for bit in range(0, 8): 
            GPIO.output(SDI, 0x80 & (dat << bit))
            GPIO.output(SRCLK, GPIO.HIGH)
            time.sleep(0.001)
            GPIO.output(SRCLK, GPIO.LOW)
        GPIO.output(RCLK, GPIO.HIGH)
        time.sleep(0.001)
        GPIO.output(RCLK, GPIO.LOW)

    def main():
        while True:
            # Trasmetti il codice uno per uno dalla lista segCode
            for code in segCode:
                hc595_shift(code)
                print ("segCode[%s]: 0x%02X"%(segCode.index(code), code)) # %02X significa doppia cifra HEX da stampare
                time.sleep(0.5)

    def destroy():
        GPIO.cleanup()

    if __name__ == '__main__':
        setup()
        try:
            main()
        except KeyboardInterrupt:
            destroy()

**Spiegazione del Codice**

.. code-block:: python

    segCode = [0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71]

Un array di codice segmento da 0 a F in esadecimale (Catodo comune). 

.. code-block:: python

    def setup():
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(SDI, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(RCLK, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(SRCLK, GPIO.OUT, initial=GPIO.LOW)

Imposta i tre pin ds, st_cp, sh_cp in output e lo stato iniziale come livello basso.

.. code-block:: python

    GPIO.output(SDI, 0x80 & (dat << bit))

Assegna i dati dat al pin SDI(DS) per bit. Qui supponiamo che dat=0x3f (0011 1111), quando bit=2, 0x3f si sposter√† a destra (<<) di 2 bit. 1111 1100 (0x3f << 2) & 1000 0000 (0x80) = 1000 0000, √® vero.

.. code-block:: python

    GPIO.output(SRCLK, GPIO.HIGH)

Il valore iniziale di SRCLK √® stato impostato su LOW, e qui viene impostato su HIGH, per generare un impulso di fronte di salita, quindi trasferire i dati DS al registro a scorrimento.

.. code-block:: python

    GPIO.output(RCLK, GPIO.HIGH)

Il valore iniziale di RCLK √® stato impostato su LOW, e qui viene impostato su HIGH, per generare un fronte di salita, quindi trasferire i dati dal registro a scorrimento al registro di memoria.

.. note::
    Il formato esadecimale dei numeri da 0 a 15 √® (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F)

**Immagine del Fenomeno**

.. image:: ../img/image74.jpeg


