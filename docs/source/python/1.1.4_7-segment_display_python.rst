.. _1.1.4_py:

1.1.4 7-Segment-Anzeige
=============================

Einführung
-----------------

Versuchen wir, eine 7-Segment-Anzeige zu steuern, um eine Zahl von 0 bis 9 und
ein Buchstabe von A bis F anzuzeigen.

Benötigte Komponenten
------------------------------

Für dieses Projekt benötigen wir die folgenden Komponenten.

.. image:: ../img/list_7_segment.png

Es ist definitiv praktisch, ein komplettes Kit zu kaufen. Hier ist der Link:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Name	
        - ARTIKEL IN DIESEM KIT
        - LINK
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

Sie können sie auch einzeln über die untenstehenden Links kaufen.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - KOMPONENTENBESCHREIBUNG
        - KAUF-LINK

    *   - :ref:`gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`breadboard`
        - |link_breadboard_buy|
    *   - :ref:`wires`
        - |link_wires_buy|
    *   - :ref:`resistor`
        - |link_resistor_buy|
    *   - :ref:`7_segment`
        - |link_7segment_buy|
    *   - :ref:`74hc595`
        - |link_74hc595_buy|

Schaltplan
---------------------

Verbinden Sie den ST_CP-Pin des 74HC595 mit dem GPIO18 des Raspberry Pi, SH_CP mit GPIO27, DS
mit GPIO17 und die parallelen Ausgänge zu den 8 Segmenten der LED-Segmentanzeige.
Daten werden am DS-Pin in das Schieberegister eingegeben, wenn SH_CP (der Takteingang des Schieberegisters) an der steigenden Flanke ist, und ins Speicherregister, wenn ST_CP (der Takteingang des Speichers) an der steigenden Flanke ist. Dann können Sie die Zustände von SH_CP und ST_CP über die GPIOs des Raspberry Pi steuern, um die serielle Dateneingabe in parallele Datenausgabe umzuwandeln, um so die GPIOs des Raspberry Pi zu sparen und die Anzeige zu steuern.

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
============ ======== ======== ===

.. image:: ../img/schematic_7_segment.png

Experimentelle Verfahren
------------------------------

**Schritt 1:** Bauen Sie die Schaltung auf.

.. image:: ../img/image73.png

**Schritt 2:** Wechseln Sie in den Ordner des Codes.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python/

**Schritt 3:** Ausführen.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 1.1.4_7-Segment.py

Nachdem der Code ausgeführt wurde, sehen Sie die 7-Segment-Anzeige, die 0-9, A-F anzeigt.

**Code**

.. note::
    Sie können den untenstehenden Code **Bearbeiten/Zurücksetzen/Kopieren/Ausführen/Stoppen**. Aber zuerst müssen Sie zum Quellcode-Pfad, z.B. ``raphael-kit/python``, gehen. Nachdem Sie den Code geändert haben, können Sie ihn direkt ausführen, um das Ergebnis zu sehen. Nach der Bestätigung, dass keine Probleme vorliegen, können Sie den geänderten Code mit der Kopier-Taste kopieren und dann den Quellcode im Terminal über den ``nano``-Befehl öffnen und einfügen.

.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time

    # Set up pins
    SDI   = 17
    RCLK  = 18
    SRCLK = 27

    # Define a segment code from 0 to F in Hexadecimal
    segCode = [0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71]

    def setup():
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(SDI, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(RCLK, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(SRCLK, GPIO.OUT, initial=GPIO.LOW)

    # Shift the data to 74HC595
    def hc595_shift(dat):
        for bit in range(0, 8): 
            GPIO.output(SDI, 0x80 & (dat << bit))
            GPIO.output(SRCLK, GPIO.HIGH)
            time.sleep(0.001)
            GPIO.output(SRCLK, GPIO.LOW)
        GPIO.output(RCLK, GPIO.HIGH)
        time.sleep(0.001)
        GPIO.output(RCLK, GPIO.LOW)

    def main():
        while True:
            # Shift the code one by one from segCode list
            for code in segCode:
                hc595_shift(code)
                print ("segCode[%s]: 0x%02X"%(segCode.index(code), code)) # %02X means double digit HEX to print
                time.sleep(0.5)

    def destroy():
        GPIO.cleanup()

    if __name__ == '__main__':
        setup()
        try:
            main()
        except KeyboardInterrupt:
            destroy()

**Code-Erklärung**

.. code-block:: python

    segCode = [0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71]

Ein Segmentcode-Array von 0 bis F in Hexadezimal (gemeinsamer Kathode).

.. code-block:: python

    def setup():
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(SDI, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(RCLK, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(SRCLK, GPIO.OUT, initial=GPIO.LOW)

Legt ds, st_cp und sh_cp als Ausgangspins fest und initialisiert sie auf einen niedrigen Pegel.

.. code-block:: python

    GPIO.output(SDI, 0x80 & (dat << bit))

Weist den dat-Wert bitweise an SDI(DS) zu. Hier nehmen wir an, dat=0x3f(0011 1111) ist; wenn bit=2 ist, wird 0x3f um 2 Bits nach links verschoben (<<). 1111 1100 (0x3f << 2) & 1000 0000 (0x80) = 1000 0000, ergibt true.

.. code-block:: python

    GPIO.output(SRCLK, GPIO.HIGH)

Der anfängliche Wert von SRCLK wurde auf LOW gesetzt, hier wird er auf HIGH gesetzt, um einen ansteigenden Flankenimpuls zu erzeugen und das DS-Datum ins Schieberegister zu verschieben.

.. code-block:: python

    GPIO.output(RCLK, GPIO.HIGH)

Der anfängliche Wert von RCLK wurde auf LOW gesetzt, hier wird er auf HIGH gesetzt, um eine ansteigende Flanke zu erzeugen, und verschiebt die Daten vom Schieberegister ins Speicherregister.

.. note::
    Das hexadezimale Format der Zahlen 0~15 sind (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F)

Phänomen-Bild
------------------------

.. image:: ../img/image74.jpeg


