.. note::

    Ciao, benvenuto nella SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community su Facebook! Approfondisci le tue conoscenze su Raspberry Pi, Arduino ed ESP32 insieme ad altri appassionati.

    **Perch√© unirti a noi?**

    - **Supporto esperto**: Risolvi problemi post-vendita e sfide tecniche con l'aiuto della nostra comunit√† e del nostro team.
    - **Impara e condividi**: Scambia suggerimenti e tutorial per migliorare le tue competenze.
    - **Anteprime esclusive**: Ottieni accesso anticipato agli annunci di nuovi prodotti e anteprime esclusive.
    - **Sconti speciali**: Approfitta di sconti esclusivi sui nostri prodotti pi√π recenti.
    - **Promozioni festive e concorsi**: Partecipa a concorsi e promozioni durante le festivit√†.

    üëâ Sei pronto a esplorare e creare con noi? Clicca su [|link_sf_facebook|] e unisciti oggi stesso!

.. _1.1.1_py:

1.1.1 LED Lampeggiante
=========================

Introduzione
-----------------

In questo progetto, impareremo a far lampeggiare un LED tramite la programmazione. 
Attraverso le tue impostazioni, il LED pu√≤ produrre una serie di fenomeni interessanti. 
Adesso, cominciamo.

Componenti Necessari
------------------------------

In questo progetto, abbiamo bisogno dei seguenti componenti. 

.. image:: ../img/blinking_led_list.png
    :width: 800
    :align: center

√à sicuramente comodo acquistare un kit completo, ecco il link:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nome	
        - ARTICOLI IN QUESTO KIT
        - LINK
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Puoi anche acquistarli separatamente dai link qui sotto.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUZIONE AI COMPONENTI
        - LINK PER L'ACQUISTO

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|

Schema Elettrico
---------------------

In questo esperimento, collega una resistenza da 220Œ© all'anodo (il pin lungo del LED), 
poi la resistenza ai 3,3 V, e collega il catodo (il pin corto) del LED al GPIO17 del 
Raspberry Pi. Pertanto, per accendere il LED, dobbiamo impostare GPIO17 al livello basso 
(0V). Possiamo ottenere questo fenomeno tramite la programmazione.

.. note::

    **Pin11** si riferisce all'11¬∞ pin del Raspberry Pi da sinistra a destra, e i corrispondenti numeri di pin **wiringPi** e **BCM** sono mostrati nella tabella seguente.

Nella programmazione in C, consideriamo GPIO0 equivalente a 0 in wiringPi. Nel contesto del 
linguaggio Python, BCM 17 corrisponde a 17 nella colonna BCM della tabella seguente. Allo 
stesso tempo, essi corrispondono all'11¬∞ pin del Raspberry Pi, Pin 11.

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
============ ======== ======== ===

.. image:: ../img/image48.png
    :width: 800
    :align: center

Procedure Sperimentali
-----------------------------

**Passo 1:** Costruisci il circuito.

.. image:: ../img/image49.png
    :width: 800
    :align: center

**Passo 2:** Vai alla cartella del codice e avvialo.

1. Se usi uno schermo, ti consigliamo di seguire i seguenti passi.

Trova 1.1.1_BlinkingLed.py e fai doppio clic per aprirlo. Ora sei nel file.

Clicca su **Run** -> **Run Module** nella finestra e appariranno i seguenti contenuti.

Per interrompere l'esecuzione, fai semplicemente clic sul pulsante X in alto a destra per 
chiuderlo e tornerai al codice. Se modifichi il codice, prima di fare clic su **Run Module 
(F5)** devi salvarlo. Poi potrai vedere i risultati.

2. Se accedi al Raspberry Pi da remoto, digita il seguente comando:

.. raw:: html

   <run></run>

.. code-block::

   cd ~/raphael-kit/python

.. note::
    Cambia directory al percorso del codice in questo esperimento tramite ``cd``.

**Passo 3:** Esegui il codice

.. raw:: html

   <run></run>

.. code-block::

   sudo python3 1.1.1_BlinkingLed.py

.. note::
    Qui "sudo" significa superuser do, e "python" indica di eseguire il file tramite Python.

Dopo l'esecuzione del codice, vedrai il LED lampeggiare.

**Passo 4:** Se vuoi modificare il file di codice 1.1.1_BlinkingLed.py, premi ``Ctrl + C`` 
per interrompere l'esecuzione del codice. Poi digita il seguente comando per aprire 1.1.1_BlinkingLed.py:

.. raw:: html

   <run></run>

.. code-block::

   nano 1.1.1_BlinkingLed.py

.. note::
    nano √® uno strumento di editor di testo. Il comando viene utilizzato per aprire il file di codice 1.1.1_BlinkingLed.py con questo strumento.

Premi ``Ctrl+X`` per uscire. Se hai modificato il codice, apparir√† un messaggio che 
chieder√† se vuoi salvare le modifiche. Digita ``Y`` (salva) o ``N`` (non salvare).

Poi premi ``Enter`` per uscire. Digita di nuovo nano 1.1.1_BlinkingLed.py per vedere l'effetto dopo la modifica.

**Codice**

Il seguente √® il codice del programma:

.. note::

   Puoi **Modificare/Reimpostare/Copiare/Eseguire/Interrompere** il codice qui sotto. Ma prima, devi andare al percorso del codice come ``raphael-kit/python``. Dopo aver modificato il codice, puoi eseguirlo direttamente per vedere l'effetto.

.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   import RPi.GPIO as GPIO
   import time
   LedPin = 17
   def setup():
      # Imposta le modalit√† GPIO su numerazione BCM
      GPIO.setmode(GPIO.BCM)
      # Imposta la modalit√† del LedPin come output e il livello iniziale su High (3,3 V)
      GPIO.setup(LedPin, GPIO.OUT, initial=GPIO.HIGH)
   # Definisce una funzione principale per il processo principale
   def main():
      while True:
         print ('...LED ON')
         # Accende il LED
         GPIO.output(LedPin, GPIO.LOW)
         time.sleep(0.5)
         print ('LED OFF...')
         # Spegne il LED
         GPIO.output(LedPin, GPIO.HIGH)
         time.sleep(0.5)
   # Definisce una funzione destroy per pulire tutto dopo il termine dello script
   def destroy():
      # Spegne il LED
      GPIO.output(LedPin, GPIO.HIGH)
      # Libera le risorse
      GPIO.cleanup()                   
   # Se si esegue direttamente questo script, eseguire:
   if __name__ == '__main__':
      setup()
      try:
         main()
      # Quando viene premuto 'Ctrl+C', verr√† eseguita la funzione destroy().
      except KeyboardInterrupt:
         destroy()

**Spiegazione del Codice**

.. code-block:: python

   #!/usr/bin/env python3

Quando il sistema rileva questo, cercher√† il percorso di installazione di python nelle 
impostazioni dell'env, quindi chiamer√† l'interprete corrispondente per completare 
l'operazione. Serve a prevenire che l'utente non installi python nel percorso predefinito ``/usr/bin``.

.. code-block:: python

   import RPi.GPIO as GPIO

In questo modo, importiamo la libreria RPi.GPIO e definiamo una variabile, GPIO, 
per sostituire RPI.GPIO nel codice seguente.

.. code-block:: python

   import time

Importa il pacchetto time, per utilizzare la funzione di ritardo nel programma seguente.

.. code-block:: python

   LedPin = 17

Il LED √® collegato al GPIO17 della scheda di estensione a forma di T, cio√® BCM 
17.

.. code-block:: python

   def setup():
      GPIO.setmode(GPIO.BCM)
      GPIO.setup(LedPin, GPIO.OUT, initial=GPIO.HIGH)

Imposta la modalit√† del LedPin come output e il livello iniziale su High (3,3 V).

Ci sono due modi di numerare i pin IO su un Raspberry Pi all'interno di RPi.GPIO: 
numeri BOARD e numeri BCM. Nei nostri progetti, usiamo i numeri BCM. Devi configurare 
ogni canale che usi come input o output.

.. code-block:: python

   GPIO.output(LedPin, GPIO.LOW)

Imposta GPIO17 (BCM17) a 0V (livello basso). Poich√© il catodo del LED √® collegato a 
GPIO17, il LED si accender√†.

.. code-block:: python

   time.sleep(0.5)

Ritarda per 0,5 secondi. Qui, l'istruzione √® la funzione di ritardo in linguaggio C, l'unit√† √® il secondo.

.. code-block:: python

   def destroy():
      GPIO.cleanup()  

Definisce una funzione destroy per pulire tutto dopo il termine dello script.

.. code-block:: python

   if __name__ == '__main__':
      setup()
      try:
         main()
      # Quando viene premuto 'Ctrl+C', verr√† eseguita la funzione destroy().
      except KeyboardInterrupt:
         destroy()

Questa √® la struttura generale di esecuzione del codice. Quando il programma inizia a 
essere eseguito, inizializza il pin eseguendo setup(), e poi esegue il codice nella 
funzione main() per impostare il pin su livelli alti e bassi. Quando si preme ``Ctrl+C``, 
il programma eseguir√† la funzione destroy().

Immagine del Fenomeno
----------------------------

.. image:: ../img/image54.jpeg
    :width: 800
    :align: center
