.. _2.1.6_py:

2.1.6 Rotary Encoder Module
===========================

**Introduction**
------------------

In this project, you will learn about Rotary Encoder. A rotary encoder is
an electronic switch with a set of regular pulses in strictly timing
sequence. When used with IC, it can achieve increment, decrement, page
turning and other operations such as mouse scrolling, menu selection,
and so on.

**Components**
------------------

.. image:: ../img/Part_two_25.png

* :ref:`GPIO Extension Board`
* :ref:`Breadboard`
* :ref:`Rotary Encoder Module`

**Schematic Diagram**
------------------------

.. image:: ../img/image349.png
   :align: center

Experimental Procedures
-----------------------

**Step 1:** Build the circuit.

.. image:: ../img/2.1.6_fritzing.png
   :align: center

In this example, we can connect the Rotary Encoder pin directly to the
Raspberry Pi using a breadboard and 40-pin Cable, connect the GND of the Rotary 
Encoder to GND, 「+」to 5V, SW to digital GPIO27, DT to digital GPIO18, and CLK to digital GPIO
17.

**Step 2:** Open the code file.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python/

**Step 3:** Run.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.1.6_RotaryEncoder.py

You will see the count on the shell. When you turn the rotary encoder clockwise, the count is increased; when turn it counterclockwise, the count is decreased. If you press the switch on the rotary encoder, the readings will return to zero.


**Code**

.. note::

   You can **Modify/Reset/Copy/Run/Stop** the code below. But before that, you need to go to  source code path like ``raphael-kit/python``. After modifying the code, you can run it directly to see the effect.


.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   import RPi.GPIO as GPIO
   import time

   clkPin = 17    # CLK Pin
   dtPin = 18    # DT Pin
   swPin = 27    # Button Pin

   globalCounter = 0

   flag = 0
   Last_dt_Status = 0
   Current_dt_Status = 0

   def setup():
      GPIO.setmode(GPIO.BCM)       # Numbers GPIOs by physical location
      GPIO.setup(clkPin, GPIO.IN)    # input mode
      GPIO.setup(dtPin, GPIO.IN)
      GPIO.setup(swPin, GPIO.IN, pull_up_down=GPIO.PUD_UP)

   def rotaryDeal():
      global flag
      global Last_dt_Status
      global Current_dt_Status
      global globalCounter
      Last_dt_Status = GPIO.input(dtPin)
      while(not GPIO.input(clkPin)):
         Current_dt_Status = GPIO.input(dtPin)
         flag = 1
      if flag == 1:
         flag = 0
         if (Last_dt_Status == 0) and (Current_dt_Status == 1):
            globalCounter = globalCounter - 1
         if (Last_dt_Status == 1) and (Current_dt_Status == 0):
            globalCounter = globalCounter + 1

   def swISR(channel):
      global globalCounter
      globalCounter = 0

   def loop():
      global globalCounter
      tmp = 0	# Rotary Temperary

      GPIO.add_event_detect(swPin, GPIO.FALLING, callback=swISR)
      while True:
         rotaryDeal()
         if tmp != globalCounter:
            print ('globalCounter = %d' % globalCounter)
            tmp = globalCounter

   def destroy():
      GPIO.cleanup()             # Release resource

   if __name__ == '__main__':     # Program start from here
      setup()
      try:
         loop()
      except KeyboardInterrupt:  # When 'Ctrl+C' is pressed, the child program destroy() will be  executed.
         destroy()


**Code Analysis**

* Read dtPin value when clkPin is low.
* When clkPin is high, if dtPin goes from low to high, the count decreases, otherwise the count increases.
* swPin will output low when the shaft is pressed.

From this, the program flow is shown below:


.. image:: ../img/2.1.6_flow.png
   :align: center

**Phenomenon Picture**
-------------------------

.. image:: ../img/2.1.6rotary_ecoder.JPG
   :align: center