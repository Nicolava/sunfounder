.. _2.1.6_py:

2.1.6 ロータリーエンコーダモジュール
====================================

はじめに
------------------

このプロジェクトでは、ロータリーエンコーダについて学びます。ロータリーエンコーダは、厳密なタイミングシーケンスで規則的なパルスを持つ電子スイッチです。ICと組み合わせると、インクリメント、デクリメント、ページめくり、マウスのスクロールやメニュー選択など、さまざまな操作を実現できます。

必要な部品
------------------------------

このプロジェクトでは、以下のコンポーネントが必要です。

.. image:: ../img/Part_two_25.png

キット全体を購入すると便利です、リンクはこちらです：

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - 名前
        - このキットのアイテム
        - リンク
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

以下のリンクからそれぞれ個別に購入することもできます。

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - コンポーネントの紹介
        - 購入リンク

    *   - :ref:`cpn_gpio_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_rotary_encoder`
        - |link_rotary_encoder_buy|

回路図
------------------------

.. image:: ../img/image349.png
   :align: center

実験手順
-----------------------

**ステップ1:** 回路を組む。

.. image:: ../img/2.1.6_fritzing.png
   :align: center

この例では、ブレッドボードと40ピンケーブルを使用して、ロータリーエンコーダのピンをRaspberry Piに直接接続します。ロータリーエンコーダのGNDをGNDに、「+」を5Vに、SWをデジタルGPIO27に、DTをデジタルGPIO18に、CLKをデジタルGPIO17に接続します。

**ステップ2:** コードファイルを開く。

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python/

**ステップ3:** 実行。

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.1.6_RotaryEncoder.py

シェル上でカウントが表示されます。ロータリーエンコーダを時計回りに回すとカウントが増加し、反時計回りに回すとカウントが減少します。ロータリーエンコーダのスイッチを押すと、読み取り値がゼロに戻ります。

**コード**

.. note::

   下のコードは **修正/リセット/コピー/実行/停止** が可能です。しかし、それを行う前に、ソースコードのパス（例： ``raphael-kit/python`` ）に移動する必要があります。コードを修正した後、そのまま実行して効果を確認できます。

.. raw:: html

    <run></run>



.. code-block:: python

   #!/usr/bin/env python3
   import RPi.GPIO as GPIO
   import time

   clkPin = 17    # CLK Pin
   dtPin = 18    # DT Pin
   swPin = 27    # Button Pin

   globalCounter = 0

   flag = 0
   Last_dt_Status = 0
   Current_dt_Status = 0

   def setup():
      GPIO.setmode(GPIO.BCM)       # Numbers GPIOs by physical location
      GPIO.setup(clkPin, GPIO.IN)    # input mode
      GPIO.setup(dtPin, GPIO.IN)
      GPIO.setup(swPin, GPIO.IN, pull_up_down=GPIO.PUD_UP)

   def rotaryDeal():
      global flag
      global Last_dt_Status
      global Current_dt_Status
      global globalCounter
      Last_dt_Status = GPIO.input(dtPin)
      while(not GPIO.input(clkPin)):
         Current_dt_Status = GPIO.input(dtPin)
         flag = 1
      if flag == 1:
         flag = 0
         if (Last_dt_Status == 0) and (Current_dt_Status == 1):
            globalCounter = globalCounter - 1
         if (Last_dt_Status == 1) and (Current_dt_Status == 0):
            globalCounter = globalCounter + 1

   def swISR(channel):
      global globalCounter
      globalCounter = 0

   def loop():
      global globalCounter
      tmp = 0	# Rotary Temperary

      GPIO.add_event_detect(swPin, GPIO.FALLING, callback=swISR)
      while True:
         rotaryDeal()
         if tmp != globalCounter:
            print ('globalCounter = %d' % globalCounter)
            tmp = globalCounter

   def destroy():
      GPIO.cleanup()             # Release resource

   if __name__ == '__main__':     # Program start from here
      setup()
      try:
         loop()
      except KeyboardInterrupt:  # When 'Ctrl+C' is pressed, the child program destroy() will be  executed.
         destroy()


**コード説明**

* clkPinが低い状態でdtPinの値を読み取る。
* clkPinが高い場合、dtPinが低から高に変わるとカウントは減少し、それ以外の場合はカウントが増加する。
* シャフトが押されると、swPinは低い状態を出力する。

これに基づいて、プログラムのフローは以下の通りです：

.. image:: ../img/2.1.6_flow.png
   :align: center

現象の画像
------------------

.. image:: ../img/2.1.6rotary_ecoder.JPG
   :align: center