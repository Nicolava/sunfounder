.. note::

    Ciao, benvenuto nella SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community su Facebook! Approfondisci le tue conoscenze su Raspberry Pi, Arduino ed ESP32 insieme ad altri appassionati.

    **Perch√© unirti a noi?**

    - **Supporto esperto**: Risolvi i problemi post-vendita e le sfide tecniche con l'aiuto della nostra comunit√† e del nostro team.
    - **Impara e condividi**: Scambia suggerimenti e tutorial per migliorare le tue competenze.
    - **Anteprime esclusive**: Ottieni accesso anticipato agli annunci di nuovi prodotti e anteprime speciali.
    - **Sconti esclusivi**: Approfitta di sconti riservati sui nostri prodotti pi√π recenti.
    - **Promozioni festive e concorsi**: Partecipa a concorsi e promozioni durante le festivit√†.

    üëâ Sei pronto a esplorare e creare con noi? Clicca su [|link_sf_facebook|] e unisciti oggi stesso!

.. _2.1.6_py:

2.1.6 Modulo Encoder Rotativo
==================================

Introduzione
---------------

In questo progetto, imparerai come funziona un Encoder Rotativo. Un encoder rotativo 
√® un interruttore elettronico che genera una sequenza regolare di impulsi temporizzati. 
Quando viene utilizzato con un IC, pu√≤ essere impiegato per operazioni come incremento, 
decremento, scorrimento di pagine e altre azioni come lo scorrimento del mouse o la 
selezione dei menu.

Componenti Necessari
---------------------------------

In questo progetto, abbiamo bisogno dei seguenti componenti.

.. image:: ../img/Part_two_25.png

√à sicuramente comodo acquistare un kit completo, ecco il link:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nome	
        - ARTICOLI IN QUESTO KIT
        - LINK
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Puoi anche acquistarli separatamente dai link qui sotto.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUZIONE AI COMPONENTI
        - LINK PER L'ACQUISTO

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_rotary_encoder`
        - |link_rotary_encoder_buy|

Schema Elettrico
------------------------

.. image:: ../img/image349.png
   :align: center

Procedure Sperimentali
----------------------------

**Passo 1:** Costruisci il circuito.

.. image:: ../img/2.1.6_fritzing.png
   :align: center

In questo esempio, colleghiamo i pin dell'Encoder Rotativo direttamente al Raspberry Pi 
usando una breadboard e un cavo a 40 pin. Collega il GND dell'Encoder Rotativo a GND, 
„Äå+„Äça 5V, SW al GPIO27, DT al GPIO18 e CLK al GPIO17.

**Passo 2:** Apri il file del codice.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python/

**Passo 3:** Esegui.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.1.6_RotaryEncoder.py

Vedrai il conteggio nella shell. Quando ruoti l'encoder in senso orario, il conteggio 
aumenta; quando lo ruoti in senso antiorario, il conteggio diminuisce. Se premi 
l'interruttore sull'encoder rotativo, le letture torneranno a zero.

**Codice**

.. note::

   Puoi **Modificare/Reimpostare/Copiare/Eseguire/Interrompere** il codice qui sotto. Ma prima devi accedere al percorso del codice come ``raphael-kit/python``. Dopo aver modificato il codice, puoi eseguirlo direttamente per vedere l'effetto.


.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3
   import RPi.GPIO as GPIO
   import time

   clkPin = 17    # Pin CLK
   dtPin = 18    # Pin DT
   swPin = 27    # Pin del pulsante

   globalCounter = 0

   flag = 0
   Last_dt_Status = 0
   Current_dt_Status = 0

   def setup():
      GPIO.setmode(GPIO.BCM)       # Numerazione dei GPIO in base alla posizione fisica
      GPIO.setup(clkPin, GPIO.IN)    # Modalit√† input
      GPIO.setup(dtPin, GPIO.IN)
      GPIO.setup(swPin, GPIO.IN, pull_up_down=GPIO.PUD_UP)

   def rotaryDeal():
      global flag
      global Last_dt_Status
      global Current_dt_Status
      global globalCounter
      Last_dt_Status = GPIO.input(dtPin)
      while(not GPIO.input(clkPin)):
         Current_dt_Status = GPIO.input(dtPin)
         flag = 1
      if flag == 1:
         flag = 0
         if (Last_dt_Status == 0) and (Current_dt_Status == 1):
            globalCounter = globalCounter - 1
         if (Last_dt_Status == 1) and (Current_dt_Status == 0):
            globalCounter = globalCounter + 1

   def swISR(channel):
      global globalCounter
      globalCounter = 0

   def loop():
      global globalCounter
      tmp = 0	# Temporaneo per l'encoder

      GPIO.add_event_detect(swPin, GPIO.FALLING, callback=swISR)
      while True:
         rotaryDeal()
         if tmp != globalCounter:
            print ('globalCounter = %d' % globalCounter)
            tmp = globalCounter

   def destroy():
      GPIO.cleanup()             # Rilascia le risorse

   if __name__ == '__main__':     # Il programma inizia qui
      setup()
      try:
         loop()
      except KeyboardInterrupt:  # Quando viene premuto 'Ctrl+C', il programma destroy() verr√† eseguito.
         destroy()

**Analisi del Codice**

* Legge il valore di dtPin quando clkPin √® basso.
* Quando clkPin √® alto, se dtPin passa da basso ad alto, il conteggio diminuisce, altrimenti aumenta.
* swPin emette un segnale basso quando viene premuto l'albero dell'encoder.

Da questo, il flusso del programma √® illustrato di seguito:

.. image:: ../img/2.1.6_flow.png
   :align: center

Immagine del Fenomeno
-------------------------

.. image:: ../img/2.1.6rotary_ecoder.JPG
   :align: center