.. note::

    Ciao, benvenuto nella SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts Community su Facebook! Approfondisci le tue conoscenze su Raspberry Pi, Arduino ed ESP32 insieme ad altri appassionati.

    **Perch√© unirti a noi?**

    - **Supporto esperto**: Risolvi problemi post-vendita e sfide tecniche con l'aiuto della nostra comunit√† e del nostro team.
    - **Impara e condividi**: Scambia suggerimenti e tutorial per migliorare le tue competenze.
    - **Anteprime esclusive**: Ottieni accesso anticipato agli annunci di nuovi prodotti e anteprime esclusive.
    - **Sconti speciali**: Approfitta di sconti esclusivi sui nostri prodotti pi√π recenti.
    - **Promozioni festive e concorsi**: Partecipa a concorsi e promozioni durante le festivit√†.

    üëâ Sei pronto a esplorare e creare con noi? Clicca su [|link_sf_facebook|] e unisciti oggi stesso!

.. _1.3.1_py:

1.3.1 Motore
================

Introduzione
-----------------

In questo progetto, impareremo a utilizzare l'L293D per pilotare un motore CC e farlo 
ruotare in senso orario e antiorario. Poich√© il motore CC necessita di una corrente 
maggiore, per motivi di sicurezza, utilizziamo il modulo di alimentazione per fornire 
energia ai motori.

Componenti Necessari
------------------------------

In questo progetto, abbiamo bisogno dei seguenti componenti. 

.. image:: ../img/list_1.3.1.png

√à sicuramente comodo acquistare un kit completo, ecco il link: 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nome	
        - ARTICOLI IN QUESTO KIT
        - LINK
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Puoi anche acquistarli separatamente dai link qui sotto.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUZIONE AI COMPONENTI
        - LINK PER L'ACQUISTO

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_power_module`
        - \-
    *   - :ref:`cpn_l293d`
        - \-
    *   - :ref:`cpn_motor`
        - |link_motor_buy|

Schema Elettrico
---------------------

Collega il modulo di alimentazione alla breadboard e inserisci il cappuccio del 
ponticello sul pin da 5V, in modo che emetta una tensione di 5V. Collega il pin 
1 di L293D a GPIO22 e impostalo ad alto livello. Collega il pin2 a GPIO27 e il 
pin7 a GPIO17, quindi imposta un pin alto e l'altro basso. In questo modo, puoi 
cambiare la direzione di rotazione del motore.

.. image:: ../img/image336.png


**Procedure Sperimentali**

**Passo 1:** Costruisci il circuito.

.. image:: ../img/image117.png

.. note::
    Il modulo di alimentazione pu√≤ essere utilizzato con una batteria da 9V grazie al 
    connettore incluso nel kit. Inserisci il cappuccio del ponticello del modulo di 
    alimentazione nelle strisce di alimentazione da 5V della breadboard.

.. image:: ../img/image118.jpeg

**Passo 2:** Accedi alla cartella del codice.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/python

**Passo 3:** Esegui.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 1.3.1_Motor.py

All'avvio del codice, il motore ruota prima in senso orario per 5s, quindi si ferma 
per 5s, dopodich√© ruota in senso antiorario per 5s; successivamente, il motore si 
ferma per 5s. Questa serie di azioni verr√† eseguita ripetutamente.  

**Codice**

.. note::

    Puoi **Modificare/Reimpostare/Copiare/Eseguire/Interrompere** il codice qui sotto. 
    Ma prima devi accedere al percorso del codice come ``raphael-kit/python``. Dopo aver 
    modificato il codice, puoi eseguirlo direttamente per vedere l'effetto.


.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time

    # Imposta i pin
    MotorPin1   = 17
    MotorPin2   = 27
    MotorEnable = 22

    def setup():
        # Imposta il modo GPIO su BCM
        GPIO.setmode(GPIO.BCM)
        # Imposta i pin come output
        GPIO.setup(MotorPin1, GPIO.OUT)
        GPIO.setup(MotorPin2, GPIO.OUT)
        GPIO.setup(MotorEnable, GPIO.OUT, initial=GPIO.LOW)

    # Definisci una funzione per far girare il motore
    # La direzione deve essere
    # 1(senso orario), 0(fermo), -1(senso antiorario)
    def motor(direction):
        # Senso orario
        if direction == 1:
            # Imposta la direzione
            GPIO.output(MotorPin1, GPIO.HIGH)
            GPIO.output(MotorPin2, GPIO.LOW)
            # Attiva il motore
            GPIO.output(MotorEnable, GPIO.HIGH)
            print ("Clockwise")
        # Senso antiorario
        if direction == -1:
            # Imposta la direzione
            GPIO.output(MotorPin1, GPIO.LOW)
            GPIO.output(MotorPin2, GPIO.HIGH)
            # Attiva il motore
            GPIO.output(MotorEnable, GPIO.HIGH)
            print ("Counterclockwise")
        # Stop
        if direction == 0:
            # Disattiva il motore
            GPIO.output(MotorEnable, GPIO.LOW)
            print ("Stop")

    def main():
        # Definisci un dizionario per rendere lo script pi√π leggibile
        # CW per senso orario, CCW per senso antiorario, STOP per fermo
        directions = {'CW': 1, 'CCW': -1, 'STOP': 0}
        while True:
            # Senso orario
            motor(directions['CW'])
            time.sleep(5)
            # Fermo
            motor(directions['STOP'])
            time.sleep(5)
            # Senso antiorario
            motor(directions['CCW'])
            time.sleep(5)
            # Fermo
            motor(directions['STOP'])
            time.sleep(5)

    def destroy():
        # Ferma il motore
        GPIO.output(MotorEnable, GPIO.LOW)
        # Rilascia le risorse
        GPIO.cleanup()   

    # Se esegui questo script direttamente, fai:
    if __name__ == '__main__':
        setup()
        try:
            main()
        # Quando viene premuto 'Ctrl+C', il programma destroy() sar√† eseguito.
        except KeyboardInterrupt:
            destroy()

**Spiegazione del Codice**

.. code-block:: python

    def motor(direction):
        # Senso orario
        if direction == 1:
            # Imposta la direzione
            GPIO.output(MotorPin1, GPIO.HIGH)
            GPIO.output(MotorPin2, GPIO.LOW)
            # Attiva il motore
            GPIO.output(MotorEnable, GPIO.HIGH)
            print ("Clockwise")
    ...

Crea una funzione, ``motor()``, il cui parametro √® la direzione. Quando la condizione 
direction=1 √® soddisfatta, il motore ruota in senso orario; quando direction=-1, il 
motore ruota in senso antiorario; e con direction=0, si ferma.

.. code-block:: python

    def main():
        # Definisci un dizionario per rendere lo script pi√π leggibile
        # CW per senso orario, CCW per senso antiorario, STOP per fermo
        directions = {'CW': 1, 'CCW': -1, 'STOP': 0}
        while True:
            # Senso orario
            motor(directions['CW'])
            time.sleep(5)
            # Fermo
            motor(directions['STOP'])
            time.sleep(5)
            # Senso antiorario
            motor(directions['CCW'])
            time.sleep(5)
            # Fermo
            motor(directions['STOP'])
            time.sleep(5)
        
Nella funzione main(), crea un array, directions[], in cui CW √® uguale a 1, il valore 
di CCW √® -1, e il numero 0 si riferisce a Fermo.

All'avvio del codice, il motore ruota prima in senso orario per 5s, quindi si ferma 
per 5s, dopodich√© ruota in senso antiorario per 5s; successivamente, il motore si 
ferma per 5s. Questa serie di azioni verr√† eseguita ripetutamente.

Ora dovresti vedere la pala del motore che ruota.

Immagine del Fenomeno
-------------------------

.. image:: ../img/image119.jpeg