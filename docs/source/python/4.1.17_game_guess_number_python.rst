 
.. note::

    Bonjour et bienvenue dans la Communaut√© Facebook des passionn√©s de Raspberry Pi, Arduino et ESP32 de SunFounder ! Plongez plus profond√©ment dans l'univers des Raspberry Pi, Arduino et ESP32 avec d'autres passionn√©s.

    **Pourquoi rejoindre ?**

    - **Support d'experts** : R√©solvez les probl√®mes apr√®s-vente et les d√©fis techniques avec l'aide de notre communaut√© et de notre √©quipe.
    - **Apprendre et partager** : √âchangez des astuces et des tutoriels pour am√©liorer vos comp√©tences.
    - **Aper√ßus exclusifs** : Acc√©dez en avant-premi√®re aux annonces de nouveaux produits et aux aper√ßus.
    - **R√©ductions sp√©ciales** : Profitez de r√©ductions exclusives sur nos produits les plus r√©cents.
    - **Promotions festives et cadeaux** : Participez √† des cadeaux et des promotions de vacances.

    üëâ Pr√™t √† explorer et √† cr√©er avec nous ? Cliquez [|link_sf_facebook|] et rejoignez-nous aujourd'hui !

.. _4.1.17_py:

4.1.17 JEU - Devinez le Nombre
==============================================

Introduction
------------------

Devinez le Nombre est un jeu amusant pour les f√™tes o√π vous et vos amis tour √† tour 
saisissez un nombre (0~99). La plage de nombres devient plus petite √† chaque saisie 
jusqu'√† ce qu'un joueur trouve le bon nombre. Ensuite, le joueur est battu et puni. 
Par exemple, si le nombre chanceux est 51 que les joueurs ne peuvent pas voir, et 
que le joueur ‚ë† saisit 50, l'intervalle de nombres change √† 50~99 ; si le joueur ‚ë° 
saisit 70, l'intervalle de nombres devient 50~70 ; si le joueur ‚ë¢ saisit 51, ce 
joueur est le malchanceux. Ici, nous utilisons un pav√© num√©rique pour entrer les 
nombres et un √©cran LCD pour afficher les r√©sultats.


Composants Requis
------------------------------

Pour ce projet, nous avons besoin des composants suivants.

.. image:: ../img/list_GAME_Guess_Number.png
    :align: center

Il est certainement pratique d'acheter un kit complet, voici le lien :

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom	
        - √âL√âMENTS DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez √©galement les acheter s√©par√©ment √† partir des liens ci-dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION DU COMPOSANT
        - LIEN D'ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_keypad`
        - \-
    *   - :ref:`cpn_i2c_lcd`
        - |link_i2clcd1602_buy|


Sch√©ma de C√¢blage
-----------------------

============ ======== ======== =======
Nom T-Board  physique wiringPi BCM
GPIO18       Pin 12   1        18
GPIO23       Pin 16   4        23
GPIO24       Pin 18   5        24
GPIO25       Pin 22   6        25
SPIMOSI      Pin 19   12       10
GPIO22       Pin 15   3        22
GPIO27       Pin 13   2        27
GPIO17       Pin 11   0        17
SDA1         Pin 3    SDA1(8)  SDA1(2)
SCL1         Pin 5    SCL1(9)  SDA1(3)
============ ======== ======== =======

.. image:: ../img/Schematic_three_one12.png
   :align: center

Proc√©dures Exp√©rimentales
-----------------------------

**√âtape 1 :** Construisez le circuit.

.. image:: ../img/image273.png

**√âtape 2** : Configurer l'I2C (voir :ref:`i2c_config`.)

**√âtape 3** : Changez de r√©pertoire.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/python/

**√âtape 4** : Ex√©cutez.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 4.1.17_GAME_GuessNumber.py

Apr√®s l'ex√©cution du programme, la page initiale s'affiche sur le LCD :

.. code-block:: 

   Welcome!
   Press¬†A¬†to¬†go!

Appuyez sur ‚ÄòA‚Äô, et le jeu commencera et la page de jeu appara√Ætra sur le LCD.

.. code-block:: 

   Enter number:
   0 ‚Äπpoint‚Äπ 99

Un nombre al√©atoire ‚Äò\ **point**\ ‚Äô est produit mais non affich√© sur le LCD lorsque 
le jeu commence, et ce que vous devez faire est de le deviner. Le nombre que vous 
avez tap√© appara√Æt √† la fin de la premi√®re ligne jusqu'√† ce que le calcul final soit 
termin√©. (Appuyez sur ‚ÄòD‚Äô pour d√©marrer la comparaison, et si le nombre saisi est sup√©rieur 
√† **10**, la comparaison automatique commencera.)

La plage de nombres de ‚Äòpoint‚Äô est affich√©e sur la deuxi√®me ligne. Et vous devez taper le 
nombre dans la plage. Lorsque vous tapez un nombre, la plage se r√©tr√©cit ; si vous avez trouv√© 
le nombre chanceux par chance ou par malchance, il y aura l'affichage ‚ÄúYou've¬†got¬†it!‚Äù

.. note::

    * Si vous obtenez l'erreur ``FileNotFoundError: [Errno 2] No such file or directory: '/dev/i2c-1'``, vous devez vous r√©f√©rer √† :ref:`i2c_config` pour activer l'I2C.
    * Si vous obtenez l'erreur ``ModuleNotFoundError: No module named 'smbus2'``, veuillez ex√©cuter ``sudo pip3 install smbus2``.
    * Si l'erreur ``OSError: [Errno 121] Remote I/O error`` appara√Æt, cela signifie que le module est mal c√¢bl√© ou qu'il est d√©fectueux.
    * Si le code et le c√¢blage sont corrects, mais que l'√©cran LCD ne s'affiche toujours pas, vous pouvez tourner le potentiom√®tre √† l'arri√®re pour augmenter le contraste.

**Code**

.. note::
    Vous pouvez **Modifier/R√©initialiser/Copier/Ex√©cuter/Arr√™ter** le code ci-dessous. Mais avant cela, vous devez aller dans le chemin du code source comme ``raphael-kit/python``. Apr√®s avoir modifi√© le code, vous pouvez l'ex√©cuter directement pour voir l'effet.

.. raw:: html

    <run></run>

.. code-block:: python

   #!/usr/bin/env python3

   import RPi.GPIO as GPIO
   import time
   import LCD1602
   import random

   ##################### HERE IS THE KEYPAD LIBRARY TRANSPLANTED FROM Arduino ############
   #class Key:Define some of the properties of Key
   class Keypad():

      def __init__(self, rowsPins, colsPins, keys):
         self.rowsPins = rowsPins
         self.colsPins = colsPins
         self.keys = keys
         GPIO.setwarnings(False)
         GPIO.setmode(GPIO.BCM)
         GPIO.setup(self.rowsPins, GPIO.OUT, initial=GPIO.LOW)
         GPIO.setup(self.colsPins, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)

      def read(self):
         pressed_keys = []
         for i, row in enumerate(self.rowsPins):
               GPIO.output(row, GPIO.HIGH)
               for j, col in enumerate(self.colsPins):
                  index = i * len(self.colsPins) + j
                  if (GPIO.input(col) == 1):
                     pressed_keys.append(self.keys[index])
               GPIO.output(row, GPIO.LOW)
         return pressed_keys

   ################ EXAMPLE CODE START HERE ################  

   count = 0
   pointValue = 0
   upper=99
   lower=0

   def setup():
      global keypad, last_key_pressed,keys
      rowsPins = [18,23,24,25]
      colsPins = [10,22,27,17]
      keys = ["1","2","3","A",
               "4","5","6","B",
               "7","8","9","C",
               "*","0","#","D"]
      keypad = Keypad(rowsPins, colsPins, keys)
      last_key_pressed = []
      LCD1602.init(0x27, 1)    # init(slave address, background light)
      LCD1602.clear()
      LCD1602.write(0, 0, 'Welcome!')
      LCD1602.write(0, 1, 'Press A to Start!')

   def init_new_value():
      global pointValue,upper,count,lower
      pointValue = random.randint(0,99)
      upper = 99
      lower = 0
      count = 0
      print('point is %d' %(pointValue))
      
   def detect_point():
      global count,upper,lower
      if count > pointValue:
         if count < upper:
               upper = count 
      elif count < pointValue:
         if count > lower:
               lower = count
      elif count == pointValue:
         count = 0
         return 1
      count = 0
      return 0

   def lcd_show_input(result):
      LCD1602.clear()
      if result == 1:
         LCD1602.write(0,1,'You have got it!')
         time.sleep(5)
         init_new_value()
         lcd_show_input(0)
         return
      LCD1602.write(0,0,'Enter number:')
      LCD1602.write(13,0,str(count))
      LCD1602.write(0,1,str(lower))
      LCD1602.write(3,1,' < Point < ')
      LCD1602.write(13,1,str(upper))

   def loop():
      global keypad, last_key_pressed,count
      while(True):
         result = 0
         pressed_keys = keypad.read()
         if len(pressed_keys) != 0 and last_key_pressed != pressed_keys:
               if pressed_keys == ["A"]:
                  init_new_value()
                  lcd_show_input(0)
               elif pressed_keys == ["D"]:
                  result = detect_point()
                  lcd_show_input(result)
               elif pressed_keys[0] in keys:
                  if pressed_keys[0] in list(["A","B","C","D","#","*"]):
                     continue
                  count = count * 10
                  count += int(pressed_keys[0])
                  if count >= 10:
                     result = detect_point()
                  lcd_show_input(result)
               print(pressed_keys)
         last_key_pressed = pressed_keys
         time.sleep(0.1)

   # Define a destroy function for clean up everything after the script finished
   def destroy():
      # Release resource
      GPIO.cleanup()
      LCD1602.clear() 

   if __name__ == '__main__':     # Program start from here
      try:
         setup()
         while True:
               loop()
      except KeyboardInterrupt:   # When 'Ctrl+C' is pressed, the program destroy() will be executed.
         destroy()

**Explication du Code**

Au d√©but du code, il y a les fonctions de **keypad** et **I2C LCD1602**. Vous pouvez en apprendre 
plus sur elles dans :ref:`1.1.7_py` et :ref:`2.1.8_py`.

Voici ce que nous devons savoir :

.. code-block:: python

    def¬†init_new_value():
    ¬†¬†¬†¬†global¬†pointValue,upper,count,lower
    ¬†¬†¬†¬†pointValue¬†=¬†random.randint(0,99)
    ¬†¬†¬†¬†upper¬†=¬†99
    ¬†¬†¬†¬†lower¬†=¬†0
    ¬†¬†¬†¬†count¬†=¬†0
    ¬†¬†¬†¬†print('point¬†is¬†%d'¬†%(pointValue))

Cette fonction g√©n√®re le nombre al√©atoire ‚Äò\ **point**\ ‚Äô et r√©initialise l'indication de 
la plage du point.

.. code-block:: python

    def¬†detect_point():
    ¬†¬†¬†¬†global¬†count,upper,lower
    ¬†¬†¬†¬†if¬†count¬†>¬†pointValue:
    ¬†¬†¬†¬†¬†¬†¬†¬†if¬†count¬†<¬†upper:
    ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†upper¬†=¬†count¬†
    ¬†¬†¬†¬†elif¬†count¬†<¬†pointValue:
    ¬†¬†¬†¬†¬†¬†¬†¬†if¬†count¬†>¬†lower:
    ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†lower¬†=¬†count
    ¬†¬†¬†¬†elif¬†count¬†==¬†pointValue:
    ¬†¬†¬†¬†¬†¬†¬†¬†count¬†=¬†0
    ¬†¬†¬†¬†¬†¬†¬†¬†return¬†1
    ¬†¬†¬†¬†count¬†=¬†0
    ¬†¬†¬†¬†return¬†0

``detect_point()`` compare le nombre entr√© (**count**) avec le nombre g√©n√©r√© ‚Äú\ **point**\ ‚Äù. 
Si le r√©sultat de la comparaison est diff√©rent, **count** attribuera des valeurs √† **upper** et **lower** et retournera ‚Äò\ **0**\ ‚Äô; sinon, 
s'ils sont identiques, la fonction retourne ‚Äò\ **1**\ ‚Äô.

.. code-block:: python

    def¬†lcd_show_input(result):
    ¬†¬†¬†¬†LCD1602.clear()
    ¬†¬†¬†¬†if¬†result¬†==¬†1:
    ¬†¬†¬†¬†¬†¬†¬†¬†LCD1602.write(0,1,'You¬†have¬†got¬†it!')
    ¬†¬†¬†¬†¬†¬†¬†¬†time.sleep(5)
    ¬†¬†¬†¬†¬†¬†¬†¬†init_new_value()
    ¬†¬†¬†¬†¬†¬†¬†¬†lcd_show_input(0)
    ¬†¬†¬†¬†¬†¬†¬†¬†return
    ¬†¬†¬†¬†LCD1602.write(0,0,'Enter¬†number:')
    ¬†¬†¬†¬†LCD1602.write(13,0,str(count))
    ¬†¬†¬†¬†LCD1602.write(0,1,str(lower))
    ¬†¬†¬†¬†LCD1602.write(3,1,'¬†<¬†Point¬†<¬†')
    ¬†¬†¬†¬†LCD1602.write(13,1,str(upper))

Cette fonction sert √† afficher la page du jeu.

``str(count)``: Parce que ``write()`` ne supporte que le type de donn√©es ‚Äî **string**, 
``str()`` est n√©cessaire pour convertir le **nombre** en **cha√Æne**.

.. code-block:: python

    def¬†loop():
    ¬†¬†¬†¬†global¬†keypad,¬†last_key_pressed,count
    ¬†¬†¬†¬†while(True):
    ¬†¬†¬†¬†¬†¬†¬†¬†result¬†=¬†0
    ¬†¬†¬†¬†¬†¬†¬†¬†pressed_keys¬†=¬†keypad.read()
    ¬†¬†¬†¬†¬†¬†¬†¬†if¬†len(pressed_keys)¬†!=¬†0¬†and¬†last_key_pressed¬†!=¬†pressed_keys:
    ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†if¬†pressed_keys¬†==¬†["A"]:
    ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†init_new_value()
    ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†lcd_show_input(0)
    ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†elif¬†pressed_keys¬†==¬†["D"]:
    ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†result¬†=¬†detect_point()
    ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†lcd_show_input(result)
    ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†elif¬†pressed_keys[0]¬†in¬†keys:
    ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†if¬†pressed_keys[0]¬†in¬†list(["A","B","C","D","#","*"]):
    ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†continue
    ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†count¬†=¬†count¬†*¬†10
    ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†count¬†+=¬†int(pressed_keys[0])
    ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†if¬†count¬†>=¬†10:
    ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†result¬†=¬†detect_point()
    ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†lcd_show_input(result)
    ¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†print(pressed_keys)
    ¬†¬†¬†¬†¬†¬†¬†¬†last_key_pressed¬†=¬†pressed_keys
    ¬†¬†¬†¬†¬†¬†¬†¬†time.sleep(0.1)
¬†¬†¬†

``main()`` contient tout le processus du programme, comme montr√© ci-dessous :

1) Initialiser **I2C LCD1602** et **Keypad**.

2) V√©rifier si un bouton est press√© et obtenir la lecture du bouton.

3) Si le bouton ‚Äò\ **A**\ ‚Äô est press√©, un nombre al√©atoire **0-99** appara√Ætra et le jeu commence.

4) Si le bouton ‚Äò\ **D**\ ‚Äô est d√©tect√© comme √©tant press√©, le programme passera au jugement du r√©sultat.

5) Si le bouton **0-9** est press√©, la valeur de **count** changera ; si le **count** est sup√©rieur √† **10**, le jugement commence.

6) Les changements du jeu et ses valeurs sont affich√©s sur **LCD1602**.

Image du Ph√©nom√®ne
------------------------

.. image:: ../img/image274.jpeg
   :align: center