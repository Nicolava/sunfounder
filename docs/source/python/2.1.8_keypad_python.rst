.. _2.1.8_py:

2.1.8 Tastenfeld
================

Einführung
-----------------

Ein Tastenfeld ist ein rechteckiges Array von Tasten. In diesem Projekt werden wir es verwenden, um Zeichen einzugeben.

Benötigte Komponenten
---------------------

Für dieses Projekt benötigen wir die folgenden Komponenten.

.. image:: ../img/list_2.1.5_keypad.png

Es ist definitiv praktisch, ein ganzes Kit zu kaufen, hier ist der Link:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Name	
        - ARTIKEL IN DIESEM KIT
        - LINK
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

Sie können diese auch separat über die untenstehenden Links kaufen.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - KOMPONENTENVORSTELLUNG
        - KAUF-LINK

    *   - :ref:`cpn_gpio_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_keypad`
        - \-

Schaltplan
----------

.. image:: ../img/image315.png

.. image:: ../img/image316.png

Experimentelle Verfahren
----------------------------

**Schritt 1:** Bauen Sie den Schaltkreis.

.. image:: ../img/image186.png

**Schritt 2:** Öffnen Sie die Code-Datei.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/python/

**Schritt 3:** Ausführen.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 2.1.8_Keypad.py

Nachdem der Code ausgeführt wurde, werden die Werte der gedrückten Tasten auf dem Tastenfeld (Tastenwert) auf dem Bildschirm angezeigt.

**Code**

.. note::

    Sie können den untenstehenden Code **Modifizieren/Zurücksetzen/Kopieren/Ausführen/Stoppen**. Aber zuerst müssen Sie zum Quellcode-Pfad gehen, wie z.B. ``raphael-kit/python``. Nachdem Sie den Code geändert haben, können Sie ihn direkt ausführen, um das Ergebnis zu sehen.

.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time

    class Keypad():

        def __init__(self, rowsPins, colsPins, keys):
            self.rowsPins = rowsPins
            self.colsPins = colsPins
            self.keys = keys
            GPIO.setwarnings(False)
            GPIO.setmode(GPIO.BCM)
            GPIO.setup(self.rowsPins, GPIO.OUT, initial=GPIO.LOW)
            GPIO.setup(self.colsPins, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)

        def read(self):
            pressed_keys = []
            for i, row in enumerate(self.rowsPins):
                GPIO.output(row, GPIO.HIGH)
                for j, col in enumerate(self.colsPins):
                    index = i * len(self.colsPins) + j
                    if (GPIO.input(col) == 1):
                        pressed_keys.append(self.keys[index])
                GPIO.output(row, GPIO.LOW)
            return pressed_keys

    def setup():
        global keypad, last_key_pressed
        rowsPins = [18,23,24,25]
        colsPins = [10,22,27,17]
        keys = ["1","2","3","A",
                "4","5","6","B",
                "7","8","9","C",
                "*","0","#","D"]
        keypad = Keypad(rowsPins, colsPins, keys)
        last_key_pressed = []

    def loop():
        global keypad, last_key_pressed
        pressed_keys = keypad.read()
        if len(pressed_keys) != 0 and last_key_pressed != pressed_keys:
            print(pressed_keys)
        last_key_pressed = pressed_keys
        time.sleep(0.1)

    # Define a destroy function for clean up everything after the script finished
    def destroy():
        # Release resource
        GPIO.cleanup() 

    if __name__ == '__main__':     # Program start from here
        try:
            setup()
            while True:
                loop()
        except KeyboardInterrupt:   # When 'Ctrl+C' is pressed, the program destroy() will be executed.
            destroy()

**Code-Erklärung**

.. code-block:: python

    def setup():
        global keypad, last_key_pressed
        rowsPins = [18,23,24,25]
        colsPins = [10,22,27,17]
        keys = ["1","2","3","A",
                "4","5","6","B",
                "7","8","9","C",
                "*","0","#","D"]
        keypad = Keypad(rowsPins, colsPins, keys)
        last_key_pressed = []

Jede Taste der Matrix-Tastatur wird im Array keys[] deklariert und die Pins für jede Reihe und Spalte festgelegt.

.. code-block:: python

    def loop():
        global keypad, last_key_pressed
        pressed_keys = keypad.read()
        if len(pressed_keys) != 0 and last_key_pressed != pressed_keys:
            print(pressed_keys)
        last_key_pressed = pressed_keys
        time.sleep(0.1)

Dies ist der Teil der Hauptfunktion, der den Tastenwert liest und ausgibt.

Die Funktion ``keyRead()`` liest den Zustand jeder Taste.

Die Anweisungen ``if len(pressed_keys) != 0`` und ``last_key_pressed !=
pressed_keys`` dienen dazu, zu überprüfen, ob eine Taste gedrückt wurde und welcher Zustand die gedrückte Taste hat. (Wenn Sie '3' drücken, während Sie '1' drücken, ist das Urteil zutreffend.)

Gibt den Wert der aktuell gedrückten Taste aus, wenn die Bedingung erfüllt ist.

Die Anweisung ``last_key_pressed = pressed_keys`` weist den Zustand jeder Überprüfung dem Array ``last_key_pressed`` zu, um die nächste Runde der Bedingungsüberprüfung zu erleichtern.

.. code-block:: python

    def read(self):
            pressed_keys = []
            for i, row in enumerate(self.rowsPins):
                GPIO.output(row, GPIO.HIGH)
                for j, col in enumerate(self.colsPins):
                    index = i * len(self.colsPins) + j
                    if (GPIO.input(col) == 1):
                        pressed_keys.append(self.keys[index])
                GPIO.output(row, GPIO.LOW)
            return pressed_keys

Diese Funktion weist jeder Reihe nacheinander ein hohes Niveau zu und wenn die Taste in der Spalte gedrückt wird, erhält die Spalte, in der sich die Taste befindet, ein hohes Niveau. Nachdem die zweilagige Schleife geprüft wurde, wird der Wert der Taste, deren Zustand 1 ist, im Array ``pressed_keys`` gespeichert.

Wenn Sie die Taste '3' drücken:

.. image:: ../img/image187.png

rowPins[0] erhält ein hohes Niveau und colPins[2] ein hohes Niveau.

colPins[0], colPins[1], colPins[3] erhalten ein niedriges Niveau.

Es gibt vier Zustände: 0, 0, 1, 0; und wir schreiben '3' in ``pressed_keys``.

Wenn rowPins[1], rowPins[2], rowPins[3] ein hohes Niveau erhalten, erhalten colPins[0] bis colPins[4] ein niedriges Niveau.

Die Schleife wird gestoppt, es gibt ``pressed_keys = '3'`` zurück.

Wenn Sie die Tasten '1' und '3' drücken, wird pressed_keys = ['1','3'] zurückgegeben.

Phänomen-Bild
--------------------

.. image:: ../img/image188.jpeg
