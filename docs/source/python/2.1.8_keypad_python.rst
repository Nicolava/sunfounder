.. note::

    ¬°Hola! Bienvenido a la comunidad de entusiastas de SunFounder Raspberry Pi & Arduino & ESP32 en Facebook. Sum√©rgete m√°s en Raspberry Pi, Arduino y ESP32 con otros entusiastas.

    **¬øPor qu√© unirse?**

    - **Soporte experto**: Resuelve problemas post-venta y desaf√≠os t√©cnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprende y comparte**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Vistas previas exclusivas**: Obt√©n acceso anticipado a anuncios de nuevos productos y adelantos exclusivos.
    - **Descuentos especiales**: Disfruta de descuentos exclusivos en nuestros productos m√°s nuevos.
    - **Promociones y sorteos festivos**: Participa en sorteos y promociones de temporada.

    üëâ ¬øListo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y √∫nete hoy.

.. _2.1.8_py:

2.1.8 Teclado
================

Introducci√≥n
---------------

Un teclado es una matriz rectangular de botones. En este proyecto, lo utilizaremos para ingresar caracteres.

Componentes necesarios
--------------------------

En este proyecto, necesitamos los siguientes componentes.

.. image:: ../img/list_2.1.5_keypad.png

Es definitivamente conveniente comprar un kit completo, aqu√≠ est√° el enlace:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nombre	
        - ART√çCULOS EN ESTE KIT
        - ENLACE
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

Tambi√©n puedes comprarlos por separado en los enlaces a continuaci√≥n.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCCI√ìN DEL COMPONENTE
        - ENLACE DE COMPRA

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_keypad`
        - \-

Diagrama Esquem√°tico
-------------------------

.. image:: ../img/image315.png


.. image:: ../img/image316.png


Procedimientos Experimentales
---------------------------------

**Paso 1:** Construir el circuito.

.. image:: ../img/image186.png

**Paso 2:** Abre el archivo de c√≥digo.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/python/

**Paso 3:** Ejecuta.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 2.1.8_Keypad.py

Despu√©s de ejecutar el c√≥digo, los valores de los botones 
presionados en el teclado (Valor del bot√≥n) se imprimir√°n en la pantalla.

**C√≥digo**

.. note::

    Puedes **Modificar/Restablecer/Copiar/Ejecutar/Detener** el c√≥digo a continuaci√≥n. Pero antes de eso, necesitas ir a la ruta del c√≥digo fuente como ``raphael-kit/python``. Despu√©s de modificar el c√≥digo, puedes ejecutarlo directamente para ver el efecto.

.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time

    class Keypad():

        def __init__(self, rowsPins, colsPins, keys):
            self.rowsPins = rowsPins
            self.colsPins = colsPins
            self.keys = keys
            GPIO.setwarnings(False)
            GPIO.setmode(GPIO.BCM)
            GPIO.setup(self.rowsPins, GPIO.OUT, initial=GPIO.LOW)
            GPIO.setup(self.colsPins, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)

        def read(self):
            pressed_keys = []
            for i, row in enumerate(self.rowsPins):
                GPIO.output(row, GPIO.HIGH)
                for j, col in enumerate(self.colsPins):
                    index = i * len(self.colsPins) + j
                    if (GPIO.input(col) == 1):
                        pressed_keys.append(self.keys[index])
                GPIO.output(row, GPIO.LOW)
            return pressed_keys

    def setup():
        global keypad, last_key_pressed
        rowsPins = [18,23,24,25]
        colsPins = [10,22,27,17]
        keys = ["1","2","3","A",
                "4","5","6","B",
                "7","8","9","C",
                "*","0","#","D"]
        keypad = Keypad(rowsPins, colsPins, keys)
        last_key_pressed = []

    def loop():
        global keypad, last_key_pressed
        pressed_keys = keypad.read()
        if len(pressed_keys) != 0 and last_key_pressed != pressed_keys:
            print(pressed_keys)
        last_key_pressed = pressed_keys
        time.sleep(0.1)

    # Define a destroy function for clean up everything after the script finished
    def destroy():
        # Release resource
        GPIO.cleanup() 

    if __name__ == '__main__':     # Program start from here
        try:
            setup()
            while True:
                loop()
        except KeyboardInterrupt:   # When 'Ctrl+C' is pressed, the program destroy() will be executed.
            destroy()

**Explicaci√≥n del C√≥digo**

.. code-block:: python

    def setup():
        global keypad, last_key_pressed
        rowsPins = [18,23,24,25]
        colsPins = [10,22,27,17]
        keys = ["1","2","3","A",
                "4","5","6","B",
                "7","8","9","C",
                "*","0","#","D"]
        keypad = Keypad(rowsPins, colsPins, keys)
        last_key_pressed = []

Declara cada tecla del teclado matricial en el array keys[] y define
los pines en cada fila y columna.

.. code-block:: python

    def loop():
        global keypad, last_key_pressed
        pressed_keys = keypad.read()
        if len(pressed_keys) != 0 and last_key_pressed != pressed_keys:
            print(pressed_keys)
        last_key_pressed = pressed_keys
        time.sleep(0.1)

Esta es la parte de la funci√≥n principal que lee e imprime el valor del bot√≥n.

La funci√≥n ``keyRead()`` leer√° el estado de cada bot√≥n.

La declaraci√≥n ``if len(pressed_keys) != 0`` y ``last_key_pressed != pressed_keys`` se utiliza para juzgar

si un bot√≥n est√° presionado y el estado del bot√≥n presionado. (Si presionas \'3\' cuando presionas \'1\', el juicio es v√°lido).

Imprime el valor de la tecla presionada actualmente cuando la condici√≥n es v√°lida.

La declaraci√≥n ``last_key_pressed = pressed_keys`` asigna el estado de cada
juicio a un array ``last_key_pressed`` para facilitar la siguiente ronda de
juicio condicional.

.. code-block:: python

    def read(self):
            pressed_keys = []
            for i, row in enumerate(self.rowsPins):
                GPIO.output(row, GPIO.HIGH)
                for j, col in enumerate(self.colsPins):
                    index = i * len(self.colsPins) + j
                    if (GPIO.input(col) == 1):
                        pressed_keys.append(self.keys[index])
                GPIO.output(row, GPIO.LOW)
            return pressed_keys

Esta funci√≥n asigna un nivel alto a cada fila por turno, y cuando se presiona 
el bot√≥n en la columna, la columna en la que se encuentra la tecla obtiene un 
nivel alto. Despu√©s de que el bucle de dos capas se juzga, el valor del bot√≥n 
cuyo estado es 1 se almacena en el array ``pressed_keys``.

Si presionas la tecla '3':

.. image:: ../img/image187.png

rowPins[0] se escribe en nivel alto, y colPins[2] obtiene nivel alto.

colPins[0], colPins[1], colPins[3] obtienen nivel bajo.

Hay cuatro estados: 0, 0, 1, 0; y escribimos \'3\' en ``pressed_keys``.

Cuando rowPins[1], rowPins[2], rowPins[3] se escriben en nivel alto,
colPins[0] ~ colPins[4] obtienen nivel bajo.

El bucle se detuvo, se devuelve ``pressed_keys = '3'``.

Si presionas las teclas '1' y '3', se devolver√° pressed_keys = [‚Äò1‚Äô,‚Äô3‚Äô].

Foto del Fen√≥meno
----------------------

.. image:: ../img/image188.jpeg


