 
.. _2.1.8_py:

2.1.8 Clavier
=================

Introduction
-----------------

Un clavier est une matrice rectangulaire de boutons. Dans ce projet, nous allons l'utiliser pour saisir des caractères.

Composants Nécessaires
--------------------------

Pour ce projet, nous avons besoin des composants suivants :

.. image:: ../img/list_2.1.5_keypad.png

Il est très pratique d'acheter un kit complet, voici le lien :

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom
        - ÉLÉMENTS DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez également les acheter séparément via les liens ci-dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION DES COMPOSANTS
        - LIEN D'ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_keypad`
        - \-

Schéma Électrique
--------------------

.. image:: ../img/image315.png


.. image:: ../img/image316.png

Procédures Expérimentales
----------------------------

**Étape 1 :** Construire le circuit.

.. image:: ../img/image186.png

**Étape 2 :** Ouvrir le fichier de code.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/python/

**Étape 3 :** Exécuter.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo python3 2.1.8_Keypad.py

Après l'exécution du code, les valeurs des boutons pressés sur le clavier (valeur du bouton) seront affichées à l'écran.

**Code**

.. note::

    Vous pouvez **Modifier/Réinitialiser/Copier/Exécuter/Arrêter** le code ci-dessous. Mais avant cela, vous devez accéder au chemin du code source comme ``raphael-kit/python``. Après avoir modifié le code, vous pouvez l'exécuter directement pour voir l'effet.

.. raw:: html

    <run></run>

.. code-block:: python

    import RPi.GPIO as GPIO
    import time

    class Keypad():

        def __init__(self, rowsPins, colsPins, keys):
            self.rowsPins = rowsPins
            self.colsPins = colsPins
            self.keys = keys
            GPIO.setwarnings(False)
            GPIO.setmode(GPIO.BCM)
            GPIO.setup(self.rowsPins, GPIO.OUT, initial=GPIO.LOW)
            GPIO.setup(self.colsPins, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)

        def read(self):
            pressed_keys = []
            for i, row in enumerate(self.rowsPins):
                GPIO.output(row, GPIO.HIGH)
                for j, col in enumerate(self.colsPins):
                    index = i * len(self.colsPins) + j
                    if (GPIO.input(col) == 1):
                        pressed_keys.append(self.keys[index])
                GPIO.output(row, GPIO.LOW)
            return pressed_keys

    def setup():
        global keypad, last_key_pressed
        rowsPins = [18,23,24,25]
        colsPins = [10,22,27,17]
        keys = ["1","2","3","A",
                "4","5","6","B",
                "7","8","9","C",
                "*","0","#","D"]
        keypad = Keypad(rowsPins, colsPins, keys)
        last_key_pressed = []

    def loop():
        global keypad, last_key_pressed
        pressed_keys = keypad.read()
        if len(pressed_keys) != 0 and last_key_pressed != pressed_keys:
            print(pressed_keys)
        last_key_pressed = pressed_keys
        time.sleep(0.1)

    # Define a destroy function for clean up everything after the script finished
    def destroy():
        # Release resource
        GPIO.cleanup() 

    if __name__ == '__main__':     # Program start from here
        try:
            setup()
            while True:
                loop()
        except KeyboardInterrupt:   # When 'Ctrl+C' is pressed, the program destroy() will be executed.
            destroy()

**Explication du Code**

.. code-block:: python

    def setup():
        global keypad, last_key_pressed
        rowsPins = [18,23,24,25]
        colsPins = [10,22,27,17]
        keys = ["1","2","3","A",                
                "4","5","6","B",                
                "7","8","9","C",                
                "*","0","#","D"]
        keypad = Keypad(rowsPins, colsPins, keys)
        last_key_pressed = []

Déclarez chaque touche du clavier matriciel dans le tableau keys[] et définissez les broches de 
chaque rangée et colonne.

.. code-block:: python

    def loop():
        global keypad, last_key_pressed
        pressed_keys = keypad.read()
        if len(pressed_keys) != 0 and last_key_pressed != pressed_keys:
            print(pressed_keys)
        last_key_pressed = pressed_keys
        time.sleep(0.1)

Voici la partie de la fonction principale qui lit et affiche la valeur du bouton.

La fonction ``keyRead()`` lira l'état de chaque bouton.

Les instructions ``if len(pressed_keys) != 0`` et ``last_key_pressed != pressed_keys`` sont utilisées pour déterminer

si une touche est enfoncée et l'état du bouton enfoncé. (Si vous appuyez sur '3' alors que '1' est enfoncé, le jugement est valide.)

Affiche la valeur de la touche actuellement enfoncée lorsque la condition est remplie.

L'instruction ``last_key_pressed = pressed_keys`` assigne l'état de chaque jugement à un tableau ``last_key_pressed`` pour faciliter le prochain jugement conditionnel.

.. code-block:: python

    def read(self):
            pressed_keys = []
            for i, row in enumerate(self.rowsPins):
                GPIO.output(row, GPIO.HIGH)
                for j, col in enumerate(self.colsPins):
                    index = i * len(self.colsPins) + j
                    if (GPIO.input(col) == 1):
                        pressed_keys.append(self.keys[index])
                GPIO.output(row, GPIO.LOW)
            return pressed_keys

Cette fonction assigne un niveau haut à chaque rangée à tour de rôle, et lorsque le bouton de la 
colonne est enfoncé, la colonne dans laquelle se trouve la touche obtient un niveau haut. Après 
que la boucle à deux niveaux a jugé, la valeur du bouton dont l'état est 1 est stockée dans le 
tableau ``pressed_keys``.

Si vous appuyez sur la touche '3':

.. image:: ../img/image187.png

rowPins[0] est écrit en niveau haut, et colPins[2] obtient un niveau haut.

colPins[0], colPins[1], colPins[3] obtiennent un niveau bas.

Il y a quatre états : 0, 0, 1, 0 ; et nous écrivons '3' dans ``pressed_keys``.

Lorsque rowPins[1], rowPins[2], rowPins[3] sont écrits en niveau haut, colPins[0] à colPins[4] obtiennent un niveau bas.

La boucle s'arrête, et retourne ``pressed_keys = ‘3’``.

Si vous appuyez sur les boutons '1' et '3', il retournera pressed_keys = ['1', '3'].


Image du Phénomène
---------------------

.. image:: ../img/image188.jpeg
