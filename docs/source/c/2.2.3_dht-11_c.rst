 
.. _2.2.3_c:

2.2.3 DHT-11
==================

Introduction
--------------

Le capteur numérique de température et d'humidité DHT11 est un capteur composite 
qui contient un signal numérique calibré de température et d'humidité. La technologie
 de collecte de modules numériques dédiés et la technologie de détection de température
  et d'humidité sont appliquées pour garantir une haute fiabilité et une excellente 
  stabilité du produit.

Les capteurs comprennent un capteur résistif d'humidité et un capteur de température
 NTC, tous deux connectés à un microcontrôleur performant de 8 bits.

Required Components
------------------------------

Dans ce projet, nous avons besoin des composants suivants. 

.. image:: ../img/list_2.2.3_dht-11.png

Il est vraiment pratique d'acheter un kit complet, voici le lien : 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nom
        - ARTICLES DANS CE KIT
        - LIEN
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Vous pouvez également les acheter séparément via les liens ci-dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION DU COMPOSANT
        - LIEN D'ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_humiture_sensor`
        - |link_humiture_buy|

Schematic Diagram
--------------------

.. image:: ../img/image326.png

Experimental Procedures
--------------------------

**Étape 1:** Construire le circuit.

.. image:: ../img/image207.png

**Étape 2:** Aller dans le dossier du code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/c/2.2.3/

**Étape 3:** Compiler le code.

.. raw:: html

   <run></run>

.. code-block::

    gcc 2.2.3_DHT.c -lwiringPi

**Étape 4:** Exécuter le fichier exécutable.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Après l'exécution du code, le programme affichera la température et l'humidité détectées
 par le DHT11 sur l'écran de l'ordinateur.

.. note::

    Si cela ne fonctionne pas après l'exécution ou s'il y a une erreur indiquant : "wiringPi.h : Aucun fichier ou dossier de ce type", veuillez vous référer à :ref:`install_wiringpi`.

**Code**

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <stdint.h>

    #define maxTim 85
    #define dhtPin 0

    int dht11_dat[5] = {0,0,0,0,0};

    void readDht11() {
        uint8_t laststate = HIGH;
        uint8_t counter = 0;
        uint8_t j = 0, i;
        float Fah; // fahrenheit
        dht11_dat[0] = dht11_dat[1] = dht11_dat[2] = dht11_dat[3] = dht11_dat[4] = 0;
        // pull pin down for 18 milliseconds
        pinMode(dhtPin, OUTPUT);
        digitalWrite(dhtPin, LOW);
        delay(18);
        // then pull it up for 40 microseconds
        digitalWrite(dhtPin, HIGH);
        delayMicroseconds(40); 
        // prepare to read the pin
        pinMode(dhtPin, INPUT);

        // detect change and read data
        for ( i=0; i< maxTim; i++) {
            counter = 0;
            while (digitalRead(dhtPin) == laststate) {
                counter++;
                delayMicroseconds(1);
                if (counter == 255) {
                    break;
                }
            }
            laststate = digitalRead(dhtPin);

            if (counter == 255) break;
            // ignore first 3 transitions
            if ((i >= 4) && (i%2 == 0)) {
                // shove each bit into the storage bytes
                dht11_dat[j/8] <<= 1;
                if (counter > 50)
                    dht11_dat[j/8] |= 1;
                j++;
            }
        }
        // check we read 40 bits (8bit x 5 ) + verify checksum in the last byte
        // print it out if data is good
        if ((j >= 40) && 
                (dht11_dat[4] == ((dht11_dat[0] + dht11_dat[1] + dht11_dat[2] + dht11_dat[3]) & 0xFF)) ) {
            Fah = dht11_dat[2] * 9. / 5. + 32;
            printf("Humidity = %d.%d %% Temperature = %d.%d *C (%.1f *F)\n", 
                    dht11_dat[0], dht11_dat[1], dht11_dat[2], dht11_dat[3], Fah);
        }
    }

    int main (void) {
        if(wiringPiSetup() == -1){ //when initialize wiring failed, print messageto screen
            printf("setup wiringPi failed !");
            return 1; 
        }
        while (1) {
            readDht11();
            delay(500); // wait 1sec to refresh
        }
        return 0 ;
    }

**Explication du code**

.. code-block:: c

    void readDht11() {
        uint8_t laststate = HIGH;
        uint8_t counter = 0;
        uint8_t j = 0, i;
        float Fah; // fahrenheit
        dht11_dat[0] = dht11_dat[1] = dht11_dat[2] = dht11_dat[3] = dht11_dat[4] = 0;
        // ...
    }

Cette fonction est utilisée pour réaliser la fonction du DHT11.

Elle peut généralement être divisée en 3 parties :

1. Préparer la lecture de la broche :

.. code-block:: c

    // pull pin down for 18 milliseconds
    pinMode(dhtPin, OUTPUT);
    digitalWrite(dhtPin, LOW);
    delay(18);
    // then pull it up for 40 microseconds
    digitalWrite(dhtPin, HIGH);
    delayMicroseconds(40); 
    // prepare to read the pin
    pinMode(dhtPin, INPUT);

Son flux de communication est déterminé par la synchronisation du travail.

.. image:: ../img/image208.png

Lorsque le DHT11 démarre, le MCU enverra un signal de bas niveau puis maintiendra le
 signal à un niveau élevé pendant 40 µs. Ensuite, la détection de l'état de l'environnement
  externe commencera.

2. Lire les données :

.. code-block:: c

    // detect change and read data  
    for ( i=0; i< maxTim; i++) {
            counter = 0;
            while (digitalRead(dhtPin) == laststate) {
                counter++;
                delayMicroseconds(1);
                if (counter == 255) {
                    break;
                }
            }
            laststate = digitalRead(dhtPin);
            if (counter == 255) break;
            // ignore first 3 transitions
            if ((i >= 4) && (i%2 == 0)) {
                // shove each bit into the storage bytes
                dht11_dat[j/8] <<= 1;
                if (counter > 50)
                    dht11_dat[j/8] |= 1;
                j++;
            }
        }

La boucle stocke les données détectées dans le tableau dht11_dat[]. DHT11
transmet des données de 40 bits à la fois. Les 16 premiers bits sont liés
à l'humidité, les 16 bits intermédiaires sont liés à la température et les
huit derniers bits sont utilisés pour la vérification. Le format des données est :

**8 bits de données entières d'humidité** + **8 bits de données décimales d'humidité** + **8 bits
de données entières de température** + **8 bits de données décimales de température** + **8 bits
de bit de contrôle**.

3. Imprimer l'humidité et la température.

.. code-block:: c

    // check we read 40 bits (8bit x 5 ) + verify checksum in the last byte
    // print it out if data is good
    if ((j >= 40) && 
            (dht11_dat[4] == ((dht11_dat[0] + dht11_dat[1] + dht11_dat[2] + dht11_dat[3]) & 0xFF)) ) {
        Fah = dht11_dat[2] * 9. / 5. + 32;
        printf("Humidity = %d.%d %% Temperature = %d.%d *C (%.1f *F)\n", 
                dht11_dat[0], dht11_dat[1], dht11_dat[2], dht11_dat[3], Fah);
    }

Lorsque le stockage des données atteint 40 bits, vérifier la validité des données
à travers le **bit de contrôle (dht11_dat[4])**, puis imprimer la température
et l'humidité.

Par exemple, si les données reçues sont 00101011 (valeur de 8 bits de l'entier de l'humidité)
00000000 (valeur de 8 bits du décimal de l'humidité) 00111100 (valeur de 8 bits de l'entier de la température)
00000000 (valeur de 8 bits du décimal de la température) 01100111 (bit de contrôle)

**Calcul :**

00101011 + 00000000 + 00111100 + 00000000 = 01100111.

Le résultat final est égal aux données du bit de contrôle, alors les données reçues
sont correctes :

Humidité = 43%, Température = 60°C.

Si cela n'est pas égal aux données du bit de contrôle, la transmission des données n'est
pas normale et les données sont reçues à nouveau.

Image du phénomène
-----------------------

.. image:: ../img/image209.jpeg
