 
.. _1.2.2_c:

1.2.2 Buzzer Passif
==========================

Introduction
---------------

Dans ce projet, nous allons apprendre à faire jouer de la musique à un buzzer passif.

Composants nécessaires
------------------------------

Dans ce projet, nous avons besoin des composants suivants. 

.. image:: ../img/list_1.2.2.png

Il est certainement pratique d'acheter un kit complet, voici le lien :

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Name	
        - ITEMS IN THIS KIT
        - LINK
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

Vous pouvez également les acheter séparément via les liens ci-dessous.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCTION DES COMPOSANTS
        - LIEN D'ACHAT

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_buzzer`
        - |link_passive_buzzer_buy|
    *   - :ref:`cpn_transistor`
        - |link_transistor_buy|

Schéma de câblage
--------------------

Dans cette expérience, un buzzer passif, un transistor PNP et une résistance de 1k sont utilisés entre la base du transistor et le GPIO pour protéger le transistor.

Lorsque le GPIO17 reçoit différentes fréquences, le buzzer passif émettra différents sons ; de cette manière, le buzzer joue de la musique.

.. image:: ../img/image333.png


Procédures expérimentales
-----------------------------

**Étape 1** : Construisez le circuit. (Le buzzer passif avec une carte de circuit verte à l'arrière.)

.. image:: ../img/image106.png

**Étape 2** : Changez de répertoire.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/c/1.2.2/

**Étape 3** : Compilez.

.. raw:: html

   <run></run>

.. code-block::

    gcc 1.2.2_PassiveBuzzer.c -lwiringPi

**Étape 4** : Exécutez.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Le code s'exécute, le buzzer joue un morceau de musique.

.. note::

    Si cela ne fonctionne pas après l'exécution, ou si un message d'erreur apparaît : "wiringPi.h: No such file or directory", veuillez vous référer à :ref:`install_wiringpi`.

**Code**

.. code-block:: c

    #include <wiringPi.h>
    #include <softTone.h>
    #include <stdio.h>

    #define BuzPin    0

    #define  CL1  131
    #define  CL2  147
    #define  CL3  165
    #define  CL4  175
    #define  CL5  196
    #define  CL6  221
    #define  CL7  248

    #define  CM1  262
    #define  CM2  294
    #define  CM3  330
    #define  CM4  350
    #define  CM5  393
    #define  CM6  441
    #define  CM7  495

    #define  CH1  525
    #define  CH2  589
    #define  CH3  661
    #define  CH4  700
    #define  CH5  786
    #define  CH6  882
    #define  CH7  990

    int song_1[] = {CM3,CM5,CM6,CM3,CM2,CM3,CM5,CM6,CH1,CM6,CM5,CM1,CM3,CM2,
                    CM2,CM3,CM5,CM2,CM3,CM3,CL6,CL6,CL6,CM1,CM2,CM3,CM2,CL7,
                    CL6,CM1,CL5};

    int beat_1[] = {1,1,3,1,1,3,1,1,1,1,1,1,1,1,3,1,1,3,1,1,1,1,1,1,1,2,1,1,
                    1,1,1,1,1,1,3};


    int song_2[] = {CM1,CM1,CM1,CL5,CM3,CM3,CM3,CM1,CM1,CM3,CM5,CM5,CM4,CM3,CM2,
                    CM2,CM3,CM4,CM4,CM3,CM2,CM3,CM1,CM1,CM3,CM2,CL5,CL7,CM2,CM1
                    };

    int beat_2[] = {1,1,1,3,1,1,1,3,1,1,1,1,1,1,3,1,1,1,2,1,1,1,3,1,1,1,3,3,2,3};

    int main(void)
    {
        int i, j;
        if(wiringPiSetup() == -1){ //when initialize wiring failed,print message to screen
            printf("setup wiringPi failed !");
            return 1;
        }

        if(softToneCreate(BuzPin) == -1){
            printf("setup softTone failed !");
            return 1;
        }

        while(1){
            printf("music is being played...\n");

            for(i=0;i<sizeof(song_1)/4;i++){
                softToneWrite(BuzPin, song_1[i]);   
                delay(beat_1[i] * 500);
            }

            for(i=0;i<sizeof(song_2)/4;i++){
                softToneWrite(BuzPin, song_2[i]);   
                delay(beat_2[i] * 500);
            }   
        }

        return 0;
    }

**Explication du code**

.. code-block:: c

    #define  CL1  131
    #define  CL2  147
    #define  CL3  165
    #define  CL4  175
    #define  CL5  196
    #define  CL6  221
    #define  CL7  248

    #define  CM1  262
    #define  CM2  294



Ces fréquences de chaque note sont indiquées ci-dessous. CL désigne une note basse, 
CM une note moyenne, CH une note haute, 1-7 correspondent aux notes C, D, E, F, G, A, B.

.. code-block:: c

    int song_1[] = {CM3,CM5,CM6,CM3,CM2,CM3,CM5,CM6,CH1,CM6,CM5,CM1,CM3,CM2,
                    CM2,CM3,CM5,CM2,CM3,CM3,CL6,CL6,CL6,CM1,CM2,CM3,CM2,CL7,
                    CL6,CM1,CL5};
    int beat_1[] = {1,1,3,1,1,3,1,1,1,1,1,1,1,1,3,1,1,3,1,1,1,1,1,1,1,2,1,1,
                    1,1,1,1,1,1,3};

Le tableau, ``song_1[]`` contient une partition musicale d'une chanson dans laquelle ``beat_1[]`` se réfère au rythme de chaque note de la chanson (0,5s par battement).

.. code-block:: c

    if(softToneCreate(BuzPin) == -1){
            printf("setup softTone failed !");
            return 1;
    }

Cela crée une broche de tonalité contrôlée par logiciel. Vous pouvez utiliser n'importe 
quelle broche GPIO et la numérotation des broches sera celle de la fonction ``wiringPiSetup()`` 
que vous avez utilisée. La valeur de retour est 0 pour le succès. Tout autre valeur indique 
une erreur et vous devez vérifier la variable globale errno pour voir ce qui a mal tourné.

.. code-block:: c

    for(i=0;i<sizeof(song_1)/4;i++){
        softToneWrite(BuzPin, song_1[i]);   
        delay(beat_1[i] * 500);
    }

Utilisez une boucle for pour jouer la chanson song_1.

Dans la condition de jugement, **i<sizeof(song_1)/4**, la division par 4 est 
utilisée car le tableau ``song_1[]`` est un tableau de type de données entier, 
et chaque élément occupe quatre octets.

Le nombre d'éléments dans ``song_1`` (le nombre de notes musicales) est obtenu 
en divisant ``sizeof(song_1)`` par 4.

Pour que chaque note joue pendant beat \* 500ms, la fonction 
``delay(beat_1[i] \* 500)`` est appelée.

Le prototype de ``softToneWrite(BuzPin, song_1[i])`` est :

.. code-block:: c

    void softToneWrite (int pin, int freq);

Cela met à jour la valeur de fréquence de la tonalité sur la broche donnée. La tonalité ne s'arrête pas de jouer tant que vous ne réglez pas la fréquence à 0.

Image du phénomène
------------------

.. image:: ../img/image107.jpeg
