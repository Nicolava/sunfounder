.. _1.1.4_c:

1.1.4 7-Segment-Anzeige
=============================

Einführung
-----------------

Versuchen wir, eine 7-Segment-Anzeige zu steuern, um eine Zahl von 0 bis 9 und
ein Buchstabe von A bis F anzuzeigen.

Benötigte Komponenten
------------------------------

Für dieses Projekt benötigen wir folgende Komponenten.

.. image:: ../img/list_7_segment.png

Es ist definitiv praktisch, ein ganzes Kit zu kaufen, hier ist der Link:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Name
        - ARTIKEL IN DIESEM KIT
        - LINK
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

Sie können sie auch einzeln über die untenstehenden Links kaufen.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - KOMPONENTENBESCHREIBUNG
        - KAUF-LINK

    *   - :ref:`gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`breadboard`
        - |link_breadboard_buy|
    *   - :ref:`wires`
        - |link_wires_buy|
    *   - :ref:`resistor`
        - |link_resistor_buy|
    *   - :ref:`7_segment`
        - |link_7segment_buy|
    *   - :ref:`74hc595`
        - |link_74hc595_buy|

Schaltplan
---------------------

Verbinden Sie den ST_CP-Pin des 74HC595 mit dem GPIO18 des Raspberry Pi, SH_CP mit GPIO27 und DS
mit GPIO17, die parallelen Ausgangsports mit den 8 Segmenten der LED-Segment-
Anzeige. Daten im DS-Pin werden in das Schieberegister eingegeben, wenn SH_CP (der Clock-Eingang des Schieberegisters) an der steigenden Flanke ist, und in das Speicherregister, wenn ST_CP (der Clock-Eingang des Speichers) an der steigenden Flanke ist. Dann können Sie die Zustände von SH_CP und ST_CP über die GPIOs des Raspberry Pi steuern, um serielle Dateneingaben in parallele Datenausgaben zu transformieren, um so GPIOs des Raspberry Pi zu sparen und die Anzeige zu steuern.

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
============ ======== ======== ===

.. image:: ../img/schematic_7_segment.png

Experimentelle Verfahren
------------------------------

**Schritt 1:** Bauen Sie den Schaltkreis.

.. image:: ../img/image73.png

**Schritt 2:** Navigieren Sie zum Code-Ordner.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/c/1.1.4/

**Schritt 3:** Kompilieren.

.. raw:: html

   <run></run>

.. code-block::

    gcc 1.1.4_7-Segment.c -lwiringPi

**Schritt 4:** Führen Sie die oben erstellte ausführbare Datei aus.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Nachdem der Code ausgeführt wurde, zeigt die 7-Segment-Anzeige 0-9, A-F an.

.. note::

    Wenn es nach dem Ausführen nicht funktioniert oder eine Fehlermeldung erscheint: \"wiringPi.h: Datei oder Verzeichnis nicht gefunden\", beziehen Sie sich bitte auf :ref:`install_wiringpi`.

**Code**

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>
    #define   SDI   0   //serial data input
    #define   RCLK  1   //memory clock input(STCP)
    #define   SRCLK 2   //shift register clock input(SHCP)
    unsigned char SegCode[16] = {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};

    void init(void){
        pinMode(SDI, OUTPUT); 
        pinMode(RCLK, OUTPUT);
        pinMode(SRCLK, OUTPUT); 
        digitalWrite(SDI, 0);
        digitalWrite(RCLK, 0);
        digitalWrite(SRCLK, 0);
    }

    void hc595_shift(unsigned char dat){
        int i;
        for(i=0;i<8;i++){
            digitalWrite(SDI, 0x80 & (dat << i));
            digitalWrite(SRCLK, 1);
            delay(1);
            digitalWrite(SRCLK, 0);
        }
            digitalWrite(RCLK, 1);
            delay(1);
            digitalWrite(RCLK, 0);
    }

    int main(void){
        int i;
        if(wiringPiSetup() == -1){ //when initialize wiring failed, print messageto screen
            printf("setup wiringPi failed !");
            return 1;
        }
        init();
        while(1){
            for(i=0;i<16;i++){
                printf("Print %1X on Segment\n", i); // %X means hex output
                hc595_shift(SegCode[i]);
                delay(500);
            }
        }
        return 0;
    }

**Code-Erklärung**


.. code-block:: c

    unsigned char SegCode[16] = {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};

Ein Segmentcode-Array von 0 bis F in Hexadezimal (Gemeinsame Kathode).

.. code-block:: c

    void init(void){
        pinMode(SDI, OUTPUT); 
        pinMode(RCLK, OUTPUT); 
        pinMode(SRCLK, OUTPUT); 
        digitalWrite(SDI, 0);
        digitalWrite(RCLK, 0);
        digitalWrite(SRCLK, 0);
    }

Setze ds, st_cp, sh_cp auf drei Pins als OUTPUT und den anfänglichen Zustand auf 0.

.. code-block:: c

    void hc595_shift(unsigned char dat){}

Um dem 74HC595's Schieberegister einen 8-Bit-Wert zuzuweisen.

.. code-block:: c

    digitalWrite(SDI, 0x80 & (dat << i));

Weise die dat Daten bitweise an SDI(DS) zu. Hier nehmen wir an, dass dat=0x3f (0011 1111) ist; wenn i=2, wird 0x3f 2 Bits nach links verschoben. 1111 1100 (0x3f << 2) & 1000 0000 (0x80) = 1000 0000, ergibt wahr.

.. code-block:: c

    digitalWrite(SRCLK, 1);

Der Anfangswert von SRCLK wurde auf 0 gesetzt, und hier wird er auf 1 gesetzt, um einen ansteigenden Flankenimpuls zu erzeugen und das DS Datum ins Schieberegister zu verschieben.

.. code-block:: c

    digitalWrite(RCLK, 1);

Der Anfangswert von RCLK wurde auf 0 gesetzt, und hier wird er auf 1 gesetzt, um eine ansteigende Flanke zu erzeugen und dann die Daten vom Schieberegister ins Speicherregister zu verschieben.

.. code-block:: c

    while(1){
            for(i=0;i<16;i++){
                printf("Print %1X on Segment\n", i); // %X means hex output
                hc595_shift(SegCode[i]);
                delay(500);
            }
        }

In dieser For-Schleife verwenden wir ``%1X``, um i als hexadezimale Zahl auszugeben. Nutzen Sie i, um den entsprechenden Segmentcode im ``SegCode[]`` Array zu finden, und verwenden Sie ``hc595_shift()`` um den SegCode ins 74HC595's Schieberegister zu übergeben.

.. note::
    Die hexadezimalen Formate der Zahlen 0~15 sind (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F)

Phänomen-Bild
--------------------

.. image:: ../img/image74.jpeg


