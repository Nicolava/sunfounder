.. note::

    Ciao, benvenuto nella community SunFounder Raspberry Pi & Arduino & ESP32 su Facebook! Esplora pi√π a fondo Raspberry Pi, Arduino ed ESP32 con altri appassionati.

    **Perch√© unirti?**

    - **Supporto Esperti**: Risolvi problemi post-vendita e sfide tecniche con l'aiuto della nostra comunit√† e del nostro team.
    - **Impara e Condividi**: Scambia suggerimenti e tutorial per migliorare le tue abilit√†.
    - **Anteprime Esclusive**: Ottieni l'accesso anticipato agli annunci di nuovi prodotti e anticipazioni.
    - **Sconti Speciali**: Goditi sconti esclusivi sui nostri prodotti pi√π recenti.
    - **Promozioni e Giveaway Festivi**: Partecipa a concorsi e promozioni per le festivit√†.

    üëâ Pronto a esplorare e creare con noi? Clicca su [|link_sf_facebook|] e unisciti oggi!

.. _1.1.1_c:

1.1.1 LED Lampeggiante
=========================

Introduzione
-----------------

In questo progetto impareremo come creare un LED lampeggiante tramite la programmazione.
Attraverso le tue impostazioni, il tuo LED pu√≤ produrre una serie di fenomeni interessanti. Ora, mettiti alla prova.

Componenti Necessari
------------------------------

In questo progetto, ci servono i seguenti componenti. 

.. image:: ../img/blinking_led_list.png
    :width: 800
    :align: center

√à decisamente comodo acquistare un kit completo, ecco il link:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nome	
        - COMPONENTI IN QUESTO KIT
        - LINK
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Puoi anche acquistarli separatamente dai link sottostanti.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUZIONE AI COMPONENTI
        - LINK D'ACQUISTO

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|

Schema Circuitale
---------------------

In questo esperimento, collega una resistenza da 220Œ© all'anodo 
(il pin lungo del LED), quindi la resistenza a 3.3 V, e collega il 
catodo (il pin corto) del LED al GPIO17 del Raspberry Pi. Pertanto, 
per accendere un LED, dobbiamo impostare il GPIO17 su basso livello (0V). 
Possiamo ottenere questo fenomeno programmando.

.. note::

    **Pin11** si riferisce all'11¬∞ pin del Raspberry Pi da sinistra a destra, 
    e i suoi numeri di pin **wiringPi** e **BCM** corrispondenti sono mostrati 
    nella tabella seguente.

Nel contenuto relativo al linguaggio C, rendiamo GPIO0 equivalente a 0 in wiringPi. Tra i contenuti relativi al linguaggio Python, BCM 17 √® 17 nella colonna BCM della tabella seguente. Allo stesso tempo, sono uguali all'11¬∞ pin sul Raspberry Pi, Pin 11.

============ ======== ======== ===
Nome T-Board fisico   wiringPi BCM
GPIO17       Pin 11   0        17
============ ======== ======== ===

.. image:: ../img/image48.png
    :width: 800
    :align: center

Procedure Sperimentali
-----------------------------

**Passo 1:** Costruisci il circuito.

.. image:: ../img/image49.png
    :width: 800
    :align: center

**Passo 2:** Vai nella cartella del codice.

1) Se utilizzi uno schermo, ti consigliamo di seguire questi passaggi.

Vai su **~/** e trova la cartella **raphael-kit**.

Trova **C** nella cartella, fai clic con il tasto destro su di essa e seleziona **Apri nel Terminale**.

.. image:: ../img/image50.png
    :width: 800
    :align: center

Quindi verr√† visualizzata una finestra come mostrato di seguito. Ora sei entrato nel percorso del codice **1.1.1_BlinkingLed.c**.

.. image:: ../img/image51.png
    :width: 800
    :align: center

Nei progetti seguenti, useremo il comando per entrare nel file di codice anzich√© fare clic con il tasto destro. Ma puoi scegliere il metodo che preferisci.

2) Se accedi al Raspberry Pi da remoto, usa ``cd`` per cambiare directory:

.. raw:: html

   <run></run>

.. code-block::

   cd ~/raphael-kit/c/1.1.1/

.. note::
    Cambia directory al percorso del codice in questo esperimento tramite cd.

In entrambi i casi, ora sei nella cartella C. Le procedure successive basate su questi due metodi sono le stesse. Andiamo avanti.

**Passo 3:** Compila il codice

.. raw:: html

   <run></run>

.. code-block::

   gcc 1.1.1_BlinkingLed.c -o BlinkingLed -lwiringPi

.. note::
    gcc √® la GNU Compiler Collection. Qui, funziona come compilatore del 
    file in linguaggio C ``1.1.1_BlinkingLed.c`` e genera un file eseguibile.

Nel comando, ``-o`` significa che stai generando un output (il carattere subito 
dopo -o √® il nome del file di output dopo la compilazione, qui verr√† generato un 
eseguibile chiamato ``BlinkingLed``) e ``-lwiringPi`` serve per caricare la libreria 
wiringPi (``l`` √® l'abbreviazione di library).

**Passo 4:** Esegui il file eseguibile generato nel passaggio precedente.

.. raw:: html

   <run></run>

.. code-block::

   sudo ./BlinkingLed

.. note::

   Se non funziona dopo l'esecuzione o compare un errore: \"wiringPi.h: Nessun file o directory\", fai riferimento a :ref:`install_wiringpi`.

Per controllare il GPIO, devi eseguire il programma con il comando 
``sudo`` (superuser do). Il comando ``./`` indica la directory corrente. 
L'intero comando serve per eseguire il file ``BlinkingLed`` nella directory corrente.

Dopo aver eseguito il codice, vedrai il LED lampeggiare.

Se vuoi modificare il file di codice ``1.1.1_BlinkingLed.c``, interrompi l'esecuzione del codice e poi digita il seguente comando per aprirlo:

.. raw:: html

   <run></run>

.. code-block::

   nano 1.1.1_BlinkingLed.c

Premi ``Ctrl+X`` per uscire. Se hai modificato il codice, verr√† visualizzato un 
prompt che chiede se salvare o meno le modifiche. Digita ``Y`` (salva) o ``N`` 
(non salvare). Poi premi ``Invio`` per uscire. Ripeti ``Passo 3`` e ``Passo 4`` 
per vedere l'effetto dopo la modifica.

.. image:: ../img/image53.png
    :width: 800
    :align: center

**Codice**

Il codice del programma √® mostrato di seguito:

.. code-block:: c

   #include <wiringPi.h>  
   #include <stdio.h>
   #define LedPin      0
   int main(void)
   {
      // Se l'inizializzazione di wiring fallisce, stampa il messaggio sullo schermo
      if(wiringPiSetup() == -1){
         printf("setup wiringPi failed !");
         return 1;
      }
      pinMode(LedPin, OUTPUT);// Imposta LedPin come output per scrivere un valore su di esso.
      while(1){
         // Accendi il LED
         digitalWrite(LedPin, LOW);
         printf("...LED on\n");
         delay(500);
         // Spegni il LED
         digitalWrite(LedPin, HIGH);
         printf("LED off...\n");
         delay(500);
      }
      return 0;
   }

**Spiegazione del Codice**

.. code-block:: c

   #include <wiringPi.h>

La libreria di driver hardware √® progettata per il linguaggio C del Raspberry Pi. 
L'aggiunta di questa libreria facilita l'inizializzazione dell'hardware e l'output 
delle porte I/O, PWM, ecc.

.. code-block:: c

   #include <stdio.h>

Libreria standard di input/output. La funzione printf utilizzata per stampare i 
dati visualizzati sullo schermo √® realizzata da questa libreria. Ci sono molte altre 
funzioni che puoi esplorare.

.. code-block:: c

   #define LedPin 0

Il pin GPIO17 della T_Extension Board corrisponde al GPIO0 in wiringPi. Assegna 
GPIO0 a LedPin, LedPin rappresenta GPIO0 nel codice successivo.

.. code-block:: c

   if(wiringPiSetup() == -1){
      printf("setup wiringPi failed !");
      return 1;

Questa funzione inizializza wiringPi e presume che il programma chiamante utilizzi 
lo schema di numerazione dei pin di wiringPi.

Questa funzione deve essere chiamata con privilegi di root. Se l'inizializzazione 
wiring fallisce, stampa un messaggio sullo schermo. La funzione ``return`` viene 
utilizzata per uscire dalla funzione corrente. Usare ``return`` nella funzione
 ``main()`` termina il programma.

.. code-block:: c

   pinMode(LedPin, OUTPUT);

Imposta ``LedPin`` come output per scrivere un valore su di esso.

.. code-block:: c

   digitalWrite(LedPin, LOW);

Imposta GPIO0 a 0V (livello basso). Poich√© il catodo del LED √® collegato a GPIO0, il LED si accender√† se GPIO0 √® impostato su livello basso. Al contrario, impostando GPIO0 su livello alto, il LED si spegner√†.

.. code-block:: c

   printf("...LED¬†off\n");

La funzione printf √® una funzione di libreria standard e il suo prototipo di 
funzione √® nel file di intestazione ``stdio.h``.

La forma generale della chiamata √®: ``printf(" stringa di controllo del formato ", 
colonne della tabella di output)``. La stringa di controllo del formato viene 
utilizzata per specificare il formato di output, che √® diviso in stringa di 
formato e stringa non formattata. La stringa di formato inizia con ``%`` 
seguita da caratteri di formato, come ``%d`` per l'output di interi decimali. 
Le stringhe non formattate vengono stampate come prototipi. Qui viene utilizzata 
una stringa non formattata, seguita da ``\n`` che √® un carattere di nuova linea, 
che rappresenta l'interruzione automatica della riga dopo la stampa di una stringa.

.. code-block:: c

   delay(500);

Mantiene lo stato corrente ALTO o BASSO per 500ms.

Questa √® una funzione che sospende il programma per un certo periodo di tempo. 
E la velocit√† del programma √® determinata dal nostro hardware. Qui accendiamo o 
spegniamo il LED. Se non ci fosse la funzione di ritardo, il programma eseguirebbe 
l'intero programma molto velocemente e in loop continuo. Quindi abbiamo bisogno della 
funzione di ritardo per aiutarci a scrivere e debugare il programma.

.. code-block:: c

   return 0;

Di solito, viene posizionato alla fine della funzione main, indicando che la funzione restituisce 0 al termine dell'esecuzione.

Immagine del Fenomeno
-------------------------

.. image:: ../img/image54.jpeg
   :width: 800
   :align: center
