.. note::

    Ciao, benvenuto nella Community di appassionati di SunFounder Raspberry Pi & Arduino & ESP32 su Facebook! Approfondisci Raspberry Pi, Arduino ed ESP32 insieme agli altri appassionati.

    **Perch√© unirti a noi?**

    - **Supporto esperto**: Risolvi problemi post-vendita e sfide tecniche con l'aiuto della nostra community e del nostro team.
    - **Impara e condividi**: Scambia suggerimenti e tutorial per migliorare le tue competenze.
    - **Anteprime esclusive**: Ottieni accesso anticipato a nuovi annunci di prodotti e anteprime.
    - **Sconti speciali**: Godi di sconti esclusivi sui nostri prodotti pi√π recenti.
    - **Promozioni festive e omaggi**: Partecipa a omaggi e promozioni speciali per le festivit√†.

    üëâ Sei pronto a esplorare e creare con noi? Clicca su [|link_sf_facebook|] e unisciti oggi stesso!

.. _3.1.3_c:

3.1.3 Allarme di Retromarcia
==============================

Introduzione
----------------

In questo progetto, utilizzeremo un LCD, un cicalino e sensori a ultrasuoni 
per realizzare un sistema di assistenza alla retromarcia. Possiamo installarlo 
su un veicolo telecomandato per simulare il processo reale di retromarcia in un garage.

Componenti necessari
------------------------------

In questo progetto avremo bisogno dei seguenti componenti. 

.. image:: ../img/list_Reversing_Alarm.png
    :align: center

√à sicuramente conveniente acquistare un kit completo, ecco il link: 

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nome	
        - ELEMENTI IN QUESTO KIT
        - LINK
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Puoi anche acquistare i componenti separatamente dai link qui sotto.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUZIONE COMPONENTI
        - LINK DI ACQUISTO

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_buzzer`
        - \-
    *   - :ref:`cpn_transistor`
        - |link_transistor_buy|
    *   - :ref:`cpn_ultrasonic_sensor`
        - |link_ultrasonic_buy|
    *   - :ref:`cpn_i2c_lcd`
        - |link_i2clcd1602_buy|

Schema elettrico
--------------------

Il sensore a ultrasuoni rileva la distanza tra s√© e l'ostacolo,
che verr√† visualizzata sullo schermo LCD in codice. Allo stesso tempo,
il sensore a ultrasuoni far√† emettere al cicalino un suono di avvertimento
con frequenza variabile in base al valore della distanza.

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO23       Pin 16   4        23
GPIO24       Pin 18   5        24
GPIO17       Pin 11   0        17
SDA1         Pin 3             
SCL1         Pin 5             
============ ======== ======== ===

.. image:: ../img/Schematic_three_one3.png
   :align: center

Procedura sperimentale
---------------------------

**Passo 1:** Costruisci il circuito.

.. image:: ../img/image242.png

**Passo 2:** Cambia directory.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/c/3.1.3/

**Passo 3:** Compila.

.. raw:: html

   <run></run>

.. code-block:: 

    gcc 3.1.3_ReversingAlarm.c -lwiringPi

**Passo 4:** Esegui.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo ./a.out

Quando il codice viene eseguito, il modulo sensore a ultrasuoni rileva la distanza 
dall'ostacolo e quindi visualizza le informazioni sulla distanza sull'LCD1602; 
inoltre, il cicalino emette un tono di avvertimento la cui frequenza cambia in base 
alla distanza.

.. note::

    * Se appare un errore come ``wiringPi.h: Nessun file o directory``, fai riferimento a :ref:`install_wiringpi`.
    * Se ottieni l'errore ``Unable to open I2C device: No such file or directory``, devi fare riferimento a :ref:`i2c_config` per abilitare I2C e controllare se i collegamenti sono corretti.
    * Se il codice e i collegamenti sono corretti, ma l'LCD non mostra ancora contenuti, puoi regolare il contrasto tramite il potenziometro sul retro.


**Codice**

.. note::
    I seguenti codici sono incompleti. Se desideri controllare i codici completi, 
    ti consigliamo di utilizzare il comando nano 3.1.1_ReversingAlarm.c.

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>
    #include <sys/time.h>
    #include <wiringPi.h>
    #include <wiringPiI2C.h>
    #include <string.h>

    #define Trig    4
    #define Echo    5
    #define Buzzer  0

    int LCDAddr = 0x27;
    int BLEN = 1;
    int fd;

    //funzione per l'LCD
    void write_word(int data){...}

    void send_command(int comm){...}

    void send_data(int data){...}

    void lcdInit(){...}

    void clear(){...}

    void write(int x, int y, char data[]){...}

    //funzione per il sensore a ultrasuoni
    void ultraInit(void){...}

    float disMeasure(void){...}

    //funzione principale
    int main(void)
    {
        float dis;
        char result[10];
        if(wiringPiSetup() == -1){ 
            printf("setup wiringPi failed !");
            return 1;
        }

        pinMode(Buzzer,OUTPUT);
        fd = wiringPiI2CSetup(LCDAddr);
        lcdInit();
        ultraInit();

        clear();
        write(0, 0, "Ultrasonic Starting"); 
        write(1, 1, "By Sunfounder");   

        while(1){
            dis = disMeasure();
            printf("%.2f cm \n",dis);
            digitalWrite(Buzzer,LOW);
            if (dis > 400){
                clear();
                write(0, 0, "Error");
                write(3, 1, "Out of range");    
                delay(500);
            }
            else
            {
                clear();
                write(0, 0, "Distance is");
                sprintf(result,"%.2f cm",dis);
                write(5, 1, result);

                if(dis>=50)
                {delay(500);}
                else if(dis<50 & dis>20) {
                    for(int i=0;i<2;i++){
                    digitalWrite(Buzzer,HIGH);
                    delay(50);
                    digitalWrite(Buzzer,LOW);
                    delay(200);
                    }
                }
                else if(dis<=20){
                    for(int i=0;i<5;i++){
                    digitalWrite(Buzzer,HIGH);
                    delay(50);
                    digitalWrite(Buzzer,LOW);
                    delay(50);
                    }
                }
            }   
        }

        return 0;
    }

**Spiegazione del Codice**

.. code-block:: c

    pinMode(Buzzer,OUTPUT);
    fd = wiringPiI2CSetup(LCDAddr);
    lcdInit();
    ultraInit();

In questo programma, applichiamo i componenti utilizzati in precedenza. Qui utilizziamo
cicalini, LCD e ultrasuoni. Li inizializziamo come abbiamo fatto in precedenza.

.. code-block:: c

    dis = disMeasure();
     printf("%.2f cm \n",dis);
    digitalWrite(Buzzer,LOW);
    if (dis > 400){
         write(0, 0, "Error");
         write(3, 1, "Out of range");    
    }
    else
    {
        write(0, 0, "Distance is");
        sprintf(result,"%.2f cm",dis);
        write(5, 1, result);
	}

Qui otteniamo il valore del sensore a ultrasuoni e calcoliamo la distanza.

Se il valore della distanza √® superiore al valore di portata da rilevare,
viene stampato un messaggio di errore sullo schermo LCD. E se il valore della distanza √®
all'interno della portata, verranno visualizzati i risultati corrispondenti.

.. code-block:: c

    sprintf(result,"%.2f cm",dis);

Poich√© la modalit√† di output dell'LCD supporta solo il tipo carattere, e la
variabile dis memorizza un valore di tipo float, dobbiamo usare sprintf().
Questa funzione converte il valore float in caratteri e lo memorizza
nella variabile stringa result[]. %.2f significa mantenere due cifre decimali.

.. code-block:: c

    if(dis>=50)
    {delay(500);}
    else if(dis<50 & dis>20) {
        for(int i=0;i<2;i++){
        digitalWrite(Buzzer,HIGH);
        delay(50);
        digitalWrite(Buzzer,LOW);
        delay(200);
        }
    }
    else if(dis<=20){
        for(int i=0;i<5;i++){
        digitalWrite(Buzzer,HIGH);
        delay(50);
        digitalWrite(Buzzer,LOW);
        delay(50);
        }
    }

Questa condizione di controllo viene utilizzata per regolare il suono del cicalino.
In base alla distanza, pu√≤ essere suddiviso in tre
casi, ognuno dei quali generer√† frequenze sonore diverse. Poich√©
il valore totale di delay √® 500, tutti i casi forniscono un intervallo di 500 ms
per il sensore a ultrasuoni.

Immagine del Fenomeno
--------------------------

.. image:: ../img/image243.jpeg
   :align: center
