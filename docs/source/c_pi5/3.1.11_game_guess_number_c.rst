.. note::

    ¡Hola! Bienvenidos a la Comunidad de Entusiastas de SunFounder para Raspberry Pi, Arduino y ESP32 en Facebook. Sumérgete más profundamente en Raspberry Pi, Arduino y ESP32 con otros entusiastas.

    **¿Por qué unirse?**

    - **Soporte Experto**: Resuelve problemas post-venta y desafíos técnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprender y Compartir**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Previews Exclusivos**: Obtén acceso anticipado a nuevos anuncios de productos y adelantos.
    - **Descuentos Especiales**: Disfruta de descuentos exclusivos en nuestros productos más nuevos.
    - **Promociones y Sorteos Festivos**: Participa en sorteos y promociones festivas.

    👉 ¿Listo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y únete hoy mismo.

.. _3.1.11_c_pi5:

3.1.11 JUEGO – Adivina el Número
======================================

Introducción
------------------

Adivinar Números es un juego de fiesta divertido donde tú y tus amigos se turnan 
para ingresar un número (0~99). El rango se hará más pequeño con la entrada del 
número hasta que un jugador adivine correctamente el enigma. Entonces, el jugador 
es derrotado y castigado. Por ejemplo, si el número de la suerte es 51, que los 
jugadores no pueden ver, y el jugador ① ingresa 50, el rango de números cambia a 
50~99; si el jugador ② ingresa 70, el rango de números puede ser 50~70; si el 
jugador ③ ingresa 51, este jugador es el desafortunado. Aquí, usamos un teclado 
para ingresar números y una LCD para mostrar los resultados.


Componentes Requeridos
------------------------------

En este proyecto, necesitamos los siguientes componentes.

.. image:: ../img/list_GAME_Guess_Number.png
    :align: center

Es definitivamente conveniente comprar un kit completo, aquí está el enlace:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nombre
        - ELEMENTOS EN ESTE KIT
        - ENLACE
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

También puedes comprarlos por separado en los siguientes enlaces.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCCIÓN DE COMPONENTES
        - ENLACE DE COMPRA

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_keypad`
        - \-
    *   - :ref:`cpn_i2c_lcd`
        - |link_i2clcd1602_buy|

Diagrama Esquemático
-------------------------

============== ========== ======== =======
Nombre T-Board Pin físico wiringPi BCM
GPIO18         Pin 12     1        18
GPIO23         Pin 16     4        23
GPIO24         Pin 18     5        24
GPIO25         Pin 22     6        25
SPIMOSI        Pin 19     12       10
GPIO22         Pin 15     3        22
GPIO27         Pin 13     2        27
GPIO17         Pin 11     0        17
SDA1           Pin 3      SDA1(8)  SDA1(2)
SCL1           Pin 5      SCL1(9)  SDA1(3)
============== ========== ======== =======

.. image:: ../img/Schematic_three_one12.png
   :align: center

Procedimientos Experimentales
---------------------------------

**Paso 1:** Construir el circuito.

.. image:: ../img/image273.png

**Paso 2**: Configurar I2C (ver Apéndice :ref:`i2c_config`. Si ya has configurado I2C, omite este paso.)

**Paso 3**: Cambiar de directorio.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/c/3.1.11/

**Paso 4**: Compilar.

.. raw:: html

   <run></run>

.. code-block:: 

    gcc 3.1.11_GAME_GuessNumber.c -lwiringPi

**Paso 5**: Ejecutar.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo ./a.out

Después de ejecutar el programa, se mostrará la página inicial en la LCD:

.. note::

    * Si aparece un mensaje de error ``wiringPi.h: No such file or directory``, consulta :ref:`install_wiringpi`.
    * Si recibes el error ``Unable to open I2C device: No such file or directory``, consulta :ref:`i2c_config` para habilitar I2C y verificar si el cableado es correcto.
    * Si el código y el cableado están bien, pero la pantalla LCD aún no muestra contenido, puedes ajustar el potenciómetro en la parte posterior para aumentar el contraste.

.. code-block:: 

   Welcome!
   Press A to go!

Presiona ‘A’, y el juego comenzará y la página del juego aparecerá en la LCD.

.. code-block:: 

   Enter number:
   0 ‹point‹ 99

Cuando comienza el juego, se genera un número aleatorio ‘\ **point**\ ’ pero no se 
muestra en la LCD, y lo que debes hacer es adivinarlo. El número que has ingresado 
aparece al final de la primera línea hasta que se complete el cálculo final. 
(Presiona ‘D’ para iniciar la comparación, y si el número ingresado es mayor que **10**, 
la comparación automática comenzará.)

El rango de números de ‘point’ se muestra en la segunda línea. Y debes ingresar el número 
dentro del rango. Cuando ingresas un número, el rango se reduce; si obtuviste el número 
de la suerte afortunadamente o desafortunadamente, aparecerá “You've got it!”

**Explicación del Código**

En la parte inicial del código se encuentran las funciones funcionales del **teclado** 
y **I2C LCD1602**. Puedes aprender más detalles sobre ellas en :ref:`1.1.7_c_pi5` y :ref:`2.1.8_c_pi5`.

Aquí, lo que necesitamos saber es lo siguiente:

.. code-block:: c

    /****************************************/
    //Start from here
    /****************************************/
    void init(void){
        fd = wiringPiI2CSetup(LCDAddr);
        lcd_init();
        lcd_clear();
        for(int i=0 ; i<4 ; i++) {
            pinMode(rowPins[i], OUTPUT);
            pinMode(colPins[i], INPUT);
        }
        lcd_clear();
        write(0, 0, "Welcome!");
        write(0, 1, "Press A to go!");
    }

Esta función se utiliza para definir inicialmente **I2C LCD1602** y **Keypad** 
y para mostrar “Welcome!” y “Press A to go!”.

.. code-block:: c

    void init_new_value(void){
        srand(time(0));
        pointValue = rand()%100;
        upper = 99;
        lower = 0;
        count = 0;
        printf("point is %d\n",pointValue);
    }

La función produce el número aleatorio ‘\ **point**\ ’ y restablece el rango de pista del punto.

.. code-block:: c

    bool detect_point(void){
        if(count > pointValue){
            if(count < upper){
                upper = count;
            }
        }
        else if(count < pointValue){
            if(count > lower){
                lower = count;
            }
        }
        else if(count = pointValue){
            count = 0;
            return 1;
        }
        count = 0;
        return 0;
    }

detect_point() compara el número ingresado con el “point” producido. 
Si el resultado de la comparación es que no son iguales, **count** 
asignará valores a **upper** y **lower** y devolverá ‘\ **0**\ ’; 
de lo contrario, si el resultado indica que son iguales, devolverá ‘\ **1**\ ’.

.. code-block:: c

    void lcd_show_input(bool result){
        char *str=NULL;
        str =(char*)malloc(sizeof(char)*3);
        lcd_clear();
        if (result == 1){
            write(0,1,"You've got it!");
            delay(5000);
            init_new_value();
            lcd_show_input(0);
            return;
        }
        write(0,0,"Enter number:");
        Int2Str(str,count);
        write(13,0,str);
        Int2Str(str,lower);
        write(0,1,str);
        write(3,1,"<Point<");
        Int2Str(str,upper);
        write(12,1,str);
    }

Esta función se encarga de mostrar la página del juego. Presta atención a la 
función **Int2Str(str,count)**, que convierte estas variables **count**, **lower** y
 **upper** de **entero** a **cadena de caracteres** para la correcta visualización en **lcd**.

.. code-block:: c

    int main(){
        unsigned char pressed_keys[BUTTON_NUM];
        unsigned char last_key_pressed[BUTTON_NUM];
        if(wiringPiSetup() == -1){ //when initialize wiring failed,print messageto screen
            printf("setup wiringPi failed !");
            return 1; 
        }
        init();
        init_new_value();
        while(1){
            keyRead(pressed_keys);
            bool comp = keyCompare(pressed_keys, last_key_pressed);
            if (!comp){
                if(pressed_keys[0] != 0){
                    bool result = 0;
                    if(pressed_keys[0] == 'A'){
                        init_new_value();
                        lcd_show_input(0);
                    }
                    else if(pressed_keys[0] == 'D'){
                        result = detect_point();
                        lcd_show_input(result);
                    }
                    else if(pressed_keys[0] >='0' && pressed_keys[0] <= '9'){
                        count = count * 10;
                        count = count + (pressed_keys[0] - 48);
                        if (count>=10){
                            result = detect_point();
                        }
                        lcd_show_input(result);
                    }
                }
                keyCopy(last_key_pressed, pressed_keys);
            }
            delay(100);
        }
        return 0;   
    }

Main() contiene todo el proceso del programa, como se muestra a continuación:

1) Inicializa **I2C LCD1602** y **Keypad**.

2) Usa **init_new_value()** para crear un número aleatorio **0-99**.

3) Determina si se presiona el botón y obtiene la lectura del botón.

4) Si se presiona el botón ‘\ **A**\ ’, aparecerá un número aleatorio **0-99** y comenzará el juego.

5) Si se detecta que se ha presionado el botón ‘\ **D**\ ’, el programa entrará en la evaluación 
del resultado y mostrará el resultado en la LCD. Este paso ayuda a que también puedas evaluar el 
resultado cuando solo presionas un número y luego el botón ‘\ **D**\ ’.

6) Si se presiona el botón **0-9**, el valor de **count** cambiará; si **count** es mayor que
 **10**, entonces comenzará la evaluación.

7) Los cambios del juego y sus valores se muestran en **LCD1602**.

Imagen del Fenómeno
------------------------

.. image:: ../img/image274.jpeg
   :align: center