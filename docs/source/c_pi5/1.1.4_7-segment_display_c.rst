.. nota::

    Ciao, benvenuto nella Community di appassionati di SunFounder Raspberry Pi & Arduino & ESP32 su Facebook! Approfondisci Raspberry Pi, Arduino ed ESP32 insieme ad altri appassionati.

    **Perch√© unirti a noi?**

    - **Supporto esperto**: Risolvi problemi post-vendita e sfide tecniche con l'aiuto della nostra comunit√† e del nostro team.
    - **Impara e condividi**: Scambia consigli e tutorial per migliorare le tue competenze.
    - **Anteprime esclusive**: Ottieni accesso anticipato agli annunci di nuovi prodotti e alle anteprime.
    - **Sconti speciali**: Approfitta di sconti esclusivi sui nostri prodotti pi√π recenti.
    - **Promozioni festive e omaggi**: Partecipa a omaggi e promozioni festive.

    üëâ Pronto a esplorare e creare con noi? Clicca su [|link_sf_facebook|] e unisciti oggi stesso!

.. _1.1.4_c_pi5:

1.1.4 Display a 7 Segmenti
=============================

Introduzione
-----------------

Proviamo a pilotare un display a 7 segmenti per mostrare una cifra da 0 a 9 e da A a F.

Componenti necessari
------------------------------

In questo progetto, abbiamo bisogno dei seguenti componenti. 

.. image:: ../img/list_7_segment.png

√à sicuramente conveniente acquistare un kit completo, ecco il link:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nome	
        - COMPONENTI IN QUESTO KIT
        - LINK
    *   - Raphael Kit
        - 337
        - |link_Raphael_kit|

Puoi anche acquistarli separatamente dai link sottostanti.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUZIONE COMPONENTI
        - LINK PER L'ACQUISTO

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_7_segment`
        - |link_7segment_buy|
    *   - :ref:`cpn_74hc595`
        - |link_74hc595_buy|

Schema di Collegamento
--------------------------

Collega il pin ST_CP del 74HC595 al GPIO18 del Raspberry Pi, SH_CP al GPIO27, 
DS al GPIO17, e le uscite parallele ai 7 segmenti del display LED. Inserisci 
i dati nel pin DS per il registro a scorrimento quando SH_CP (l'ingresso del 
clock del registro a scorrimento) √® al fronte di salita, e nel registro di 
memoria quando ST_CP (l'ingresso del clock della memoria) √® al fronte di salita. 
Poi puoi controllare gli stati di SH_CP e ST_CP tramite i GPIO del Raspberry Pi 
per trasformare i dati in ingresso seriale in dati in uscita parallela, risparmiando 
cos√¨ i GPIO del Raspberry Pi e pilotando il display.

============ ======== ======== ===
T-Board Name physical wiringPi BCM
GPIO17       Pin 11   0        17
GPIO18       Pin 12   1        18
GPIO27       Pin 13   2        27
============ ======== ======== ===

.. image:: ../img/schematic_7_segment.png


Procedure Sperimentali
------------------------------

**Passo 1:** Costruisci il circuito.

.. image:: ../img/image73.png

**Passo 2:** Accedi alla cartella del codice.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/c/1.1.4/

**Passo 3:** Compila il codice.

.. raw:: html

   <run></run>

.. code-block::

    gcc 1.1.4_7-Segment.c -lwiringPi

**Passo 4:** Esegui il file eseguibile.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Dopo l'esecuzione del codice, vedrai il display a 7 segmenti mostrare le cifre da 0 a 9, e le lettere da A a F.

.. note::

    Se non funziona dopo l'esecuzione o appare un errore come: \"wiringPi.h: No such file or directory\", consulta :ref:`install_wiringpi`.

**Codice**

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>
    #define   SDI   0   //ingresso dati seriale
    #define   RCLK  1   //ingresso clock memoria (STCP)
    #define   SRCLK 2   //ingresso clock registro a scorrimento (SHCP)
    unsigned char SegCode[16] = {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};

    void init(void){
        pinMode(SDI, OUTPUT); 
        pinMode(RCLK, OUTPUT);
        pinMode(SRCLK, OUTPUT); 
        digitalWrite(SDI, 0);
        digitalWrite(RCLK, 0);
        digitalWrite(SRCLK, 0);
    }

    void hc595_shift(unsigned char dat){
        int i;
        for(i=0;i<8;i++){
            digitalWrite(SDI, 0x80 & (dat << i));
            digitalWrite(SRCLK, 1);
            delay(1);
            digitalWrite(SRCLK, 0);
        }
            digitalWrite(RCLK, 1);
            delay(1);
            digitalWrite(RCLK, 0);
    }

    int main(void){
        int i;
        if(wiringPiSetup() == -1){ //quando l'inizializzazione di wiring fallisce, stampa un messaggio a schermo
            printf("setup wiringPi failed !");
            return 1;
        }
        init();
        while(1){
            for(i=0;i<16;i++){
                printf("Print %1X on Segment\n", i); // %X means hex output
                hc595_shift(SegCode[i]);
                delay(500);
            }
        }
        return 0;
    }

**Spiegazione del Codice**

.. code-block:: c

    unsigned char SegCode[16] = {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};

Una matrice di codici di segmento da 0 a F in esadecimale (catodo comune).

.. code-block:: c

    void init(void){
        pinMode(SDI, OUTPUT); 
        pinMode(RCLK, OUTPUT); 
        pinMode(SRCLK, OUTPUT); 
        digitalWrite(SDI, 0);
        digitalWrite(RCLK, 0);
        digitalWrite(SRCLK, 0);
    }

Imposta i pin ds, st_cp, sh_cp come OUTPUT, e lo stato iniziale a 0.

.. code-block:: c

    void hc595_shift(unsigned char dat){}

Assegna un valore a 8 bit al registro a scorrimento del 74HC595.

.. code-block:: c

    digitalWrite(SDI, 0x80 & (dat << i));

Assegna il dato dat a SDI (DS) bit per bit. Supponiamo che dat=0x3f (0011 1111, quando i=2, 0x3f si sposter√† a sinistra (<<) di 2 bit. 1111 1100 (0x3f << 2) & 1000 0000 (0x80) = 1000 0000, √® vero.

.. code-block:: c

    digitalWrite(SRCLK, 1);

Il valore iniziale di SRCLK era impostato su 0, e qui √® impostato su 1, per generare un impulso di salita, quindi sposta i dati DS nel registro a scorrimento.

.. code-block:: c

    digitalWrite(RCLK, 1);

Il valore iniziale di RCLK era impostato su 0, e qui √® impostato su 1, per generare un impulso di salita, quindi sposta i dati dal registro a scorrimento al registro di memoria.

.. code-block:: c

    while(1){
            for(i=0;i<16;i++){
                printf("Print %1X on Segment\n", i); // %X means hex output
                hc595_shift(SegCode[i]);
                delay(500);
            }
        }

In questo ciclo for, usiamo ``%1X`` per stampare i come numero esadecimale. Applica i per trovare il codice del segmento corrispondente nell'array ``SegCode[]``, e utilizza ``hc595_shift()`` per trasferire il codice SegCode nel registro a scorrimento del 74HC595.

.. note::
    Il formato esadecimale dei numeri da 0 a 15 √® (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F)

**Immagine del Fenomeno**

.. image:: ../img/image74.jpeg


