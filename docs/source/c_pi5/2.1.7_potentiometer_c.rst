.. note::

    Ciao, benvenuto nella community di SunFounder Raspberry Pi & Arduino & ESP32 Enthusiasts su Facebook! Immergiti pi√π a fondo in Raspberry Pi, Arduino ed ESP32 con altri appassionati.

    **Perch√© unirti?**

    - **Supporto esperto**: Risolvi i problemi post-vendita e le sfide tecniche con l'aiuto della nostra community e del nostro team.
    - **Impara e Condividi**: Scambia suggerimenti e tutorial per migliorare le tue competenze.
    - **Anteprime esclusive**: Ottieni accesso anticipato a nuovi annunci di prodotti e anteprime.
    - **Sconti speciali**: Goditi sconti esclusivi sui nostri prodotti pi√π recenti.
    - **Promozioni festive e omaggi**: Partecipa a omaggi e promozioni festive.

    üëâ Pronto a esplorare e creare con noi? Clicca su [|link_sf_facebook|] e unisciti oggi stesso!

.. _2.1.7_c_pi5:

2.1.7 Potenziometro
======================

Introduzione
---------------

La funzione ADC pu√≤ essere utilizzata per convertire segnali analogici in 
segnali digitali, e in questo esperimento, utilizziamo l'ADC0834 per ottenere 
questa funzione. Qui, implementiamo questo processo utilizzando un potenziometro. 
Il potenziometro cambia una grandezza fisica, ovvero la tensione, che viene convertita 
dalla funzione ADC.

Componenti necessari
------------------------

In questo progetto abbiamo bisogno dei seguenti componenti.

.. image:: ../img/list_2.1.4_potentiometer.png

√à sicuramente conveniente acquistare un kit completo, ecco il link:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nome	
        - ELEMENTI IN QUESTO KIT
        - LINK
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Puoi anche acquistarli separatamente dai link sottostanti.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUZIONE COMPONENTE
        - LINK PER L'ACQUISTO

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_led`
        - |link_led_buy|
    *   - :ref:`cpn_potentiometer`
        - |link_potentiometer_buy|
    *   - :ref:`cpn_adc0834`
        - \-

Schema elettrico
--------------------

.. image:: ../img/image311.png


.. image:: ../img/image312.png


Procedure sperimentali
--------------------------

**Passo 1:** Costruisci il circuito.

.. image:: ../img/image180.png


.. note::
    Si prega di posizionare il chip facendo riferimento alla posizione 
    corrispondente raffigurata nell'immagine. Nota che le scanalature 
    sul chip devono essere a sinistra quando viene posizionato.

**Passo 2:** Apri il file del codice.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/raphael-kit/c/2.1.7/

**Passo 3:** Compila il codice.

.. raw:: html

   <run></run>

.. code-block::

    gcc 2.1.7_Potentiometer.c -lwiringPi

**Passo 4:** Esegui.

.. raw:: html

   <run></run>

.. code-block::

    sudo ./a.out

Dopo l'esecuzione del codice, ruota la manopola sul potenziometro e l'intensit√† del LED cambier√† di conseguenza.

.. note::

    Se non funziona dopo l'esecuzione o compare un messaggio di errore: \"wiringPi.h: No such file or directory\", consulta :ref:`install_wiringpi`.

Codice
--------

.. code-block:: c

    #include <wiringPi.h>
    #include <stdio.h>
    #include <softPwm.h>

    typedef unsigned char uchar;
    typedef unsigned int uint;

    #define     ADC_CS    0
    #define     ADC_CLK   1
    #define     ADC_DIO   2
    #define     LedPin    3

    uchar get_ADC_Result(uint channel)
    {
        uchar i;
        uchar dat1=0, dat2=0;
        int sel = channel > 1 & 1;
        int odd = channel & 1;

        digitalWrite(ADC_CLK, 1);
        delayMicroseconds(2);
        digitalWrite(ADC_CLK, 0);
        delayMicroseconds(2);

        pinMode(ADC_DIO, OUTPUT);
        digitalWrite(ADC_CS, 0);
        // Start bit
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        //Single End mode
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // ODD
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,odd);  delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        //Select
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,sel);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);
        
        delayMicroseconds(2);
        digitalWrite(ADC_CLK,0);
        delayMicroseconds(2);

        for(i=0;i<8;i++)
        {
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);

            pinMode(ADC_DIO, INPUT);
            dat1=dat1<<1 | digitalRead(ADC_DIO);
        }

        for(i=0;i<8;i++)
        {
            dat2 = dat2 | ((uchar)(digitalRead(ADC_DIO))<<i);
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);
        }

        digitalWrite(ADC_CS,1);
        pinMode(ADC_DIO, OUTPUT);
        return(dat1==dat2) ? dat1 : 0;
    }

    int main(void)
    {
        uchar analogVal;
        if(wiringPiSetup() == -1){ //se l'inizializzazione di wiring fallisce, stampa un messaggio sullo schermo
            printf("setup wiringPi failed !");
            return 1;
        }
        softPwmCreate(LedPin,  0, 100);
        pinMode(ADC_CS,  OUTPUT);
        pinMode(ADC_CLK, OUTPUT);

        while(1){
            analogVal = get_ADC_Result(0);
            printf("Current analogVal : %d\n", analogVal);
            softPwmWrite(LedPin, analogVal);
            delay(100);
        }
        return 0;
    }

Spiegazione del codice
----------------------

.. code-block:: c

    #define     ADC_CS    0
    #define     ADC_CLK   1
    #define     ADC_DIO   2
    #define     LedPin    3

Definisci CS, CLK, DIO di ADC0834, e collegali rispettivamente a GPIO0, 
GPIO1 e GPIO2. Poi collega il LED a GPIO3.

.. code-block:: c

    uchar get_ADC_Result(uint channel)
    {
        uchar i;
        uchar dat1=0, dat2=0;
        int sel = channel > 1 & 1;
        int odd = channel & 1;

        digitalWrite(ADC_CLK, 1);
        delayMicroseconds(2);
        digitalWrite(ADC_CLK, 0);
        delayMicroseconds(2);

        pinMode(ADC_DIO, OUTPUT);
        digitalWrite(ADC_CS, 0);
        // Start bit
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        //Single End mode
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        // ODD
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,odd);  delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
        //Select
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,sel);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,1);
        
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
        digitalWrite(ADC_CLK,0);
        digitalWrite(ADC_DIO,1);    delayMicroseconds(2);

        for(i=0;i<8;i++)
        {
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);

            pinMode(ADC_DIO, INPUT);
            dat1=dat1<<1 | digitalRead(ADC_DIO);
        }

        for(i=0;i<8;i++)
        {
            dat2 = dat2 | ((uchar)(digitalRead(ADC_DIO))<<i);
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);
        }

        digitalWrite(ADC_CS,1);
        pinMode(ADC_DIO, OUTPUT);
        return(dat1==dat2) ? dat1 : 0;
    }

Esiste una funzione di ADC0834 per ottenere la conversione da analogico 
a digitale. Il flusso di lavoro specifico √® il seguente:

.. code-block:: c

    digitalWrite(ADC_CS, 0);

Imposta CS a livello basso e inizia a abilitare la conversione AD.

.. code-block:: c

    // Start bit
    digitalWrite(ADC_CLK,0);
    digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
    digitalWrite(ADC_CLK,1);    delayMicroseconds(2);

Quando si verifica la prima transizione da basso ad alto del clock, imposta DIO 
a 1 come bit di avvio. Nei seguenti tre passaggi, ci sono 3 parole di assegnazione.

.. code-block:: c

    //Single End mode
    digitalWrite(ADC_CLK,0);
    digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
    digitalWrite(ADC_CLK,1);    delayMicroseconds(2);

Non appena si verifica la seconda transizione da basso ad alto del clock, imposta 
DIO a 1 e scegli la modalit√† SGL.

.. code-block:: c

    // ODD
    digitalWrite(ADC_CLK,0);
    digitalWrite(ADC_DIO,odd);  delayMicroseconds(2);
    digitalWrite(ADC_CLK,1);    delayMicroseconds(2);

Una volta verificatasi per la terza volta, il valore di DIO √® controllato dalla 
variabile **odd**.

.. code-block:: c

    //Select
    digitalWrite(ADC_CLK,0);
    digitalWrite(ADC_DIO,sel);    delayMicroseconds(2);
    digitalWrite(ADC_CLK,1);

Il segnale CLK passa da basso a alto per la quarta volta, e il valore di DIO √® 
controllato dalla variabile **sel**.

Con la condizione che channel=0, sel=0, odd=0, le formule operative riguardanti 
**sel** e **odd** sono le seguenti:

.. code-block:: c

    int sel = channel > 1 & 1;
    int odd = channel & 1;

Quando la condizione che channel=1, sel=0, odd=1 √® soddisfatta, si prega di fare 
riferimento alla seguente tabella della logica di controllo degli indirizzi. Qui 
viene scelto CH1 e il bit di avvio viene spostato nella posizione iniziale del 
registro del multiplexer e la conversione inizia.

.. image:: ../img/image313.png


.. code-block:: c

    digitalWrite(ADC_DIO,1);    delayMicroseconds(2);
    digitalWrite(ADC_CLK,0);
    digitalWrite(ADC_DIO,1);    delayMicroseconds(2);

Qui, imposta DIO a 1 due volte, ignora questo passaggio.

.. code-block:: c

    for(i=0;i<8;i++)
        {
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);

            pinMode(ADC_DIO, INPUT);
            dat1=dat1<<1 | digitalRead(ADC_DIO);
        }

Nel primo ciclo for(), non appena il quinto impulso di CLK passa da alto a basso, 
imposta DIO in modalit√† input. Quindi inizia la conversione e il valore convertito 
viene memorizzato nella variabile dat1. Dopo otto periodi di clock, la conversione 
√® completata.

.. code-block:: c

    for(i=0;i<8;i++)
        {
            dat2 = dat2 | ((uchar)(digitalRead(ADC_DIO))<<i);
            digitalWrite(ADC_CLK,1);    delayMicroseconds(2);
            digitalWrite(ADC_CLK,0);    delayMicroseconds(2);
        }

Nel secondo ciclo for(), i valori convertiti vengono emessi tramite DO dopo altri 
otto periodi di clock e memorizzati nella variabile dat2.

.. code-block:: c

    digitalWrite(ADC_CS,1);
    pinMode(ADC_DIO, OUTPUT);
    return(dat1==dat2) ? dat1 : 0;

return(dat1==dat2) ? dat1 : 0 √® utilizzato per confrontare il valore ottenuto 
durante la conversione e il valore in uscita. Se sono uguali, viene emesso il 
valore convertito dat1; altrimenti, viene emesso 0. Qui, il flusso di lavoro 
di ADC0834 √® completato.

.. code-block:: c

    softPwmCreate(LedPin,  0, 100);

La funzione serve per utilizzare il software per creare un pin PWM, LedPin, 
quindi l'ampiezza iniziale dell'impulso √® impostata su 0 e il periodo di PWM 
√® di 100 x 100us.

.. code-block:: c

    while(1){
            analogVal = get_ADC_Result(0);
            printf("Current analogVal : %d\n", analogVal);
            softPwmWrite(LedPin, analogVal);
            delay(100);
        }

Nel programma principale, leggi il valore del canale 0 che √® stato collegato 
a un potenziometro. E memorizza il valore nella variabile analogVal, quindi 
scrivilo in LedPin. Ora puoi vedere la luminosit√† del LED cambiare in base al 
valore del potenziometro.

Immagine del fenomeno
-------------------------

.. image:: ../img/image181.jpeg
