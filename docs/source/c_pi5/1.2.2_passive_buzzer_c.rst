.. note::

    ¬°Hola! Bienvenido a la Comunidad de Entusiastas de SunFounder Raspberry Pi, Arduino y ESP32 en Facebook. Sum√©rgete en el mundo de Raspberry Pi, Arduino y ESP32 con otros entusiastas.

    **¬øPor qu√© unirte?**

    - **Soporte Experto**: Resuelve problemas postventa y desaf√≠os t√©cnicos con la ayuda de nuestra comunidad y equipo.
    - **Aprende y Comparte**: Intercambia consejos y tutoriales para mejorar tus habilidades.
    - **Preestrenos Exclusivos**: Accede anticipadamente a anuncios de nuevos productos y adelantos.
    - **Descuentos Especiales**: Disfruta de descuentos exclusivos en nuestros productos m√°s recientes.
    - **Promociones y Sorteos Festivos**: Participa en sorteos y promociones de temporada.

    üëâ ¬øListo para explorar y crear con nosotros? Haz clic en [|link_sf_facebook|] y √∫nete hoy mismo!

.. _1.2.2_c_pi5:

1.2.2 Zumbador Pasivo
===========================

Introducci√≥n
----------------

En este proyecto, aprenderemos a hacer que un zumbador pasivo reproduzca m√∫sica.

Componentes Necesarios
--------------------------------

En este proyecto, necesitamos los siguientes componentes.

.. image:: ../img/list_1.2.2.png

Es definitivamente conveniente comprar un kit completo, aqu√≠ tienes el enlace:

.. list-table::
    :widths: 20 20 20
    :header-rows: 1

    *   - Nombre	
        - ELEMENTOS EN ESTE KIT
        - ENLACE
    *   - Kit Raphael
        - 337
        - |link_Raphael_kit|

Tambi√©n puedes comprarlos por separado en los enlaces a continuaci√≥n.

.. list-table::
    :widths: 30 20
    :header-rows: 1

    *   - INTRODUCCI√ìN DEL COMPONENTE
        - ENLACE DE COMPRA

    *   - :ref:`cpn_gpio_extension_board`
        - |link_gpio_board_buy|
    *   - :ref:`cpn_breadboard`
        - |link_breadboard_buy|
    *   - :ref:`cpn_wires`
        - |link_wires_buy|
    *   - :ref:`cpn_resistor`
        - |link_resistor_buy|
    *   - :ref:`cpn_buzzer`
        - |link_passive_buzzer_buy|
    *   - :ref:`cpn_transistor`
        - |link_transistor_buy|

Diagrama Esquem√°tico
-------------------------

En este experimento, utilizamos un zumbador pasivo, un transistor PNP y una resistencia de 1k entre la base del transistor y el GPIO para proteger el transistor.

Cuando se aplican diferentes frecuencias al GPIO17, el zumbador pasivo emitir√° diferentes sonidos; de esta manera, el zumbador reproduce m√∫sica.

.. image:: ../img/image333.png


Procedimientos Experimentales
------------------------------------

**Paso 1**: Construir el circuito. (El zumbador pasivo con la placa de circuito verde en la parte posterior).

.. image:: ../img/image106.png

**Paso 2**: Cambiar el directorio.

.. raw:: html

   <run></run>

.. code-block:: 

    cd ~/raphael-kit/c/1.2.2/

**Paso 3**: Compilar.

.. raw:: html

   <run></run>

.. code-block:: 

    gcc 1.2.2_PassiveBuzzer.c -lwiringPi

**Paso 4**: Ejecutar.

.. raw:: html

   <run></run>

.. code-block:: 

    sudo ./a.out

Al ejecutar el c√≥digo, el zumbador reproduce una pieza musical.

.. note::

    Si no funciona despu√©s de ejecutar, o aparece un mensaje de error: \"wiringPi.h: No such file or directory\", consulta :ref:`install_wiringpi`.

**C√≥digo**

.. code-block:: c

    #include <wiringPi.h>
    #include <softTone.h>
    #include <stdio.h>

    #define BuzPin    0

    #define  CL1  131
    #define  CL2  147
    #define  CL3  165
    #define  CL4  175
    #define  CL5  196
    #define  CL6  221
    #define  CL7  248

    #define  CM1  262
    #define  CM2  294
    #define  CM3  330
    #define  CM4  350
    #define  CM5  393
    #define  CM6  441
    #define  CM7  495

    #define  CH1  525
    #define  CH2  589
    #define  CH3  661
    #define  CH4  700
    #define  CH5  786
    #define  CH6  882
    #define  CH7  990

    int song_1[] = {CM3,CM5,CM6,CM3,CM2,CM3,CM5,CM6,CH1,CM6,CM5,CM1,CM3,CM2,
                    CM2,CM3,CM5,CM2,CM3,CM3,CL6,CL6,CL6,CM1,CM2,CM3,CM2,CL7,
                    CL6,CM1,CL5};

    int beat_1[] = {1,1,3,1,1,3,1,1,1,1,1,1,1,1,3,1,1,3,1,1,1,1,1,1,1,2,1,1,
                    1,1,1,1,1,1,3};


    int song_2[] = {CM1,CM1,CM1,CL5,CM3,CM3,CM3,CM1,CM1,CM3,CM5,CM5,CM4,CM3,CM2,
                    CM2,CM3,CM4,CM4,CM3,CM2,CM3,CM1,CM1,CM3,CM2,CL5,CL7,CM2,CM1
                    };

    int beat_2[] = {1,1,1,3,1,1,1,3,1,1,1,1,1,1,3,1,1,1,2,1,1,1,3,1,1,1,3,3,2,3};

    int main(void)
    {
        int i, j;
        if(wiringPiSetup() == -1){ //when initialize wiring failed,print message to screen
            printf("setup wiringPi failed !");
            return 1;
        }

        if(softToneCreate(BuzPin) == -1){
            printf("setup softTone failed !");
            return 1;
        }

        while(1){
            printf("music is being played...\n");

            for(i=0;i<sizeof(song_1)/4;i++){
                softToneWrite(BuzPin, song_1[i]);   
                delay(beat_1[i] * 500);
            }

            for(i=0;i<sizeof(song_2)/4;i++){
                softToneWrite(BuzPin, song_2[i]);   
                delay(beat_2[i] * 500);
            }   
        }

        return 0;
    }
**Explicaci√≥n del C√≥digo**

.. code-block:: c

    #define  CL1  131
    #define  CL2  147
    #define  CL3  165
    #define  CL4  175
    #define  CL5  196
    #define  CL6  221
    #define  CL7  248

    #define  CM1  262
    #define  CM2  294

Estas son las frecuencias de cada nota. CL se refiere a nota baja, CM a nota media, 
CH a nota alta, y 1-7 corresponden a las notas C, D, E, F, G, A, B.

.. code-block:: c

    int song_1[] = {CM3,CM5,CM6,CM3,CM2,CM3,CM5,CM6,CH1,CM6,CM5,CM1,CM3,CM2,
                    CM2,CM3,CM5,CM2,CM3,CM3,CL6,CL6,CL6,CM1,CM2,CM3,CM2,CL7,
                    CL6,CM1,CL5};
    int beat_1[] = {1,1,3,1,1,3,1,1,1,1,1,1,1,1,3,1,1,3,1,1,1,1,1,1,1,2,1,1,
                    1,1,1,1,1,1,3};

El arreglo ``song_1[]`` almacena una partitura musical de una canci√≥n en la que ``beat_1[]`` 
se refiere al ritmo de cada nota en la canci√≥n (0.5s por cada pulso).

.. code-block:: c

    if(softToneCreate(BuzPin) == -1){
            printf("setup softTone failed !");
            return 1;
    }

Esto crea un pin de tono controlado por software. Puedes usar cualquier pin GPIO y la numeraci√≥n 
de los pines ser√° la del m√©todo ``wiringPiSetup()`` que hayas utilizado. El valor de retorno es 0 
para √©xito. Cualquier otro valor indica un error y debes verificar la variable global ``errno`` 
para ver qu√© sali√≥ mal.

.. code-block:: c

    for(i=0;i<sizeof(song_1)/4;i++){
        softToneWrite(BuzPin, song_1[i]);   
        delay(beat_1[i] * 500);
    }

Se emplea una instrucci√≥n for para reproducir song_1.

En la condici√≥n de juicio, **i<sizeof(song_1)/4**, ‚Äúdividir por 4‚Äù se usa porque el arreglo
 ``song_1[]`` es un arreglo del tipo de dato entero, y cada elemento ocupa cuatro bytes.

El n√∫mero de elementos en ``song_1`` (el n√∫mero de notas musicales) se obtiene dividiendo
 ``sizeof(song_1)`` por 4.

Para permitir que cada nota se reproduzca durante beat \* 500ms, se llama a la funci√≥n ``delay(beat_1[i] \* 500)``.

El prototipo de ``softToneWrite(BuzPin, song_1[i])`` es:

.. code-block:: c

    void softToneWrite (int pin, int freq);

Esto actualiza el valor de frecuencia de tono en el pin dado. El tono no deja de sonar hasta 
que establezcas la frecuencia en 0.

Imagen del Fen√≥meno
----------------------

.. image:: ../img/image107.jpeg